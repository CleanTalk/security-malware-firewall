<?php

use CleantalkSP\Common\DNS;
use CleantalkSP\SpbctWP\DB;
use CleantalkSP\SpbctWP\Firewall\FW;
use CleantalkSP\SpbctWP\Cron;
use CleantalkSP\SpbctWP\Helper;
use CleantalkSP\SpbctWP\SQLSchema;
use CleantalkSP\Variables\Get;

/**
 * Called by update_security_firewall remote call
 * Starts the Security Firewall update and could use a delay before start
 *
 * @param int $delay
 *
 * @return bool|string|string[]
 * @throws Exception
 */
function spbc_security_firewall_update__init( $delay = 0 ){
    
    global $spbc;
    
    sleep( $delay );
    
    // Prevent start an update if update is already running and started less than 2 minutes ago
    if(
        $spbc->fw_stats['updating_id'] &&
        time() - $spbc->fw_stats['updating__last_start'] < 120
    ){
        return true;
    }
    
    if( ! $spbc->settings['spbc_key'] ){
        return array( 'error' => 'FW UPDATE INIT: KEY_EMPTY' );
    }
    
    if( ! $spbc->data['key_is_ok'] ){
        return array( 'error' => 'FW UPDATE INIT: KEY_IS_NOT_VALID' );
    }
    
    // Set a new update ID and an update time start
    $spbc->fw_stats['updating_id']          = md5( mt_rand( 0, 100000 ) );
    $spbc->fw_stats['updating__last_start'] = time();
    $spbc->save( 'fw_stats' );
    
    // Delete update errors
    $spbc->error_delete( 'firewall_update', true );
    $spbc->error_delete( 'firewall_update', 'save_data', 'cron');
    
    $result = Helper::http__request__rc_to_host(
        'update_security_firewall__worker',
        array(
            'updating_id' => $spbc->fw_stats['updating_id'],
        ),
        array( 'async' )
    );
    
    if( ! empty( $result['error'] ) && strpos( $result['error'], 'WRONG_SITE_RESPONSE' ) !== false ){
        
        $result = spbc_security_firewall_update__worker( $spbc->fw_stats['updating_id'] );
        if( ! empty( $result['error'] ) ){
            spbc_security_firewall_update__cleanData();
        }
        
        return $result;
    }
    
    return $result;
}

/**
 * Cleans data after update error
 *
 * @return void
 */
function spbc_security_firewall_update__cleanData(){
    
    global $spbc;
    
    // Delete temporary tables if error_occurs
    FW::data_tables__deleteTemporary( DB::getInstance(), array(
        SPBC_TBL_FIREWALL_DATA,
        SPBC_TBL_FIREWALL_DATA__IPS,
        SPBC_TBL_FIREWALL_DATA__COUNTRIES,
    ) );
    
    $spbc->fw_stats['update_percent'] = 0;
    $spbc->fw_stats['updating_id'] = null;
    $spbc->save( 'fw_stats' );
}

/**
 * Updating Security FireWall data
 *
 * @param null|string $updating_id
 * @param null|string $multifile_url
 * @param null|string $url_count
 * @param null|string $current_file_num
 *
 * @return array|bool
 * @throws Exception
 */
function spbc_security_firewall_update__worker( $updating_id = null, $multifile_url = null, $url_count = null, $current_file_num = null ){
    
    global $spbc;
    
    sleep(1);
    
    $updating_id      = $updating_id   ?: Get::get( 'updating_id' );
    $multifile_url    = $multifile_url ?: Get::get( 'multifile_url' );
    $url_count        = $url_count     ?: Get::get( 'url_count' );
    $current_file_num = isset( $current_file_num ) ? $current_file_num : Get::get( 'current_file_num' );
    
    $api_key = $spbc->api_key;
    
    if( ! $spbc->data['key_is_ok'] ){
        return array( 'error' => 'KEY_IS_NOT_VALID' );
    }
    
    // Check if the update performs right now. Blocks remote calls with different ID
    // This was done to make sure that we won't have multiple updates at a time
    if( $updating_id !== $spbc->fw_stats['updating_id']	) {
        return array( 'error' => 'WRONG_UPDATE_ID' );
    }
    
    // First call. Getting files URL ( multifile )
    if( ! $multifile_url ) {
        
        // Make sure that the table exists. Creating it if not.
        spbc_activation__create_tables( SQLSchema::getSchema( 'firewall_data' ) );
        spbc_activation__create_tables( SQLSchema::getSchema( 'firewall__personal_ips' ) );
        spbc_activation__create_tables( SQLSchema::getSchema( 'firewall__personal_countries' ) );
        
        // Update only personal tables for daughter blogs
        $result = FW::data_tables__createTemporaryTablesForTables(
            DB::getInstance(),
            array(
                SPBC_TBL_FIREWALL_DATA,
                SPBC_TBL_FIREWALL_DATA__IPS,
                SPBC_TBL_FIREWALL_DATA__COUNTRIES
            )
        );
        if( ! empty( $result['error'] ) ){
            return $result;
        }
        
        // Copying data without country code
        $result = FW::data_tables__copyCountiesDataFromMainTable( DB::getInstance(), SPBC_TBL_FIREWALL_DATA );
        if( ! empty( $result['error'] ) ){
            return $result;
        }
        
        return spbc_security_firewall_update__get_multifiles( $api_key, $updating_id );
        
        // Writing data form remote GZ file
    }elseif( $url_count && $url_count > $current_file_num ){
        
        //Increment firewall entries
        $spbc->fw_stats['update_percent'] = round( ( ( (int) $current_file_num + 1 ) / (int) $url_count ), 2) * 100;
        $spbc->save( 'fw_stats' );
        
        return spbc_security_firewall_update__process_file( $multifile_url, $url_count, $current_file_num, $updating_id );
        
        // Main update is complete. Adding exclusions.
    }elseif( $url_count && $url_count === $current_file_num ){
        
        return spbc_security_firewall_update__process_exclusions( $multifile_url, $updating_id );
        
        // End of updating
    }else{
        
        global $wpdb;
        
        //Increment firewall entries
        $tables_to_work_with = array(
            SPBC_TBL_FIREWALL_DATA,
            SPBC_TBL_FIREWALL_DATA__IPS,
            SPBC_TBL_FIREWALL_DATA__COUNTRIES
        );
        
        $result = FW::data_tables__delete( DB::getInstance(), $tables_to_work_with );
        if( ! empty( $result['error'] ) ){
            return $result;
        }
        
        $result = FW::data_tables__makeTemporaryPermanent( DB::getInstance(), $tables_to_work_with );
        if( ! empty( $result['error'] ) ){
            return $result;
        }
        
        $result = FW::data_tables__clearUnusedCountriesDataFromMainTable( DB::getInstance() ); // Clear useless entries about countries in the ain table
        if( ! empty( $result['error'] ) ){
            return $result;
        }
        
        //Files array is empty update sfw stats
        $spbc->fw_stats['update_percent'] = 0;
        $spbc->fw_stats['updating_id'] = null;
        $spbc->fw_stats['updating_last_start'] = 0;
        $spbc->fw_stats['last_updated'] = current_time('timestamp');
        $spbc->fw_stats['entries'] =
            $wpdb->get_var('SELECT COUNT(*) FROM ' . SPBC_TBL_FIREWALL_DATA ) +
            $wpdb->get_var('SELECT COUNT(*) FROM ' . SPBC_TBL_FIREWALL_DATA__IPS );
        
        $spbc->save('fw_stats');
        
        $spbc->error_delete( 'firewall_update', true );
        $spbc->error_delete( 'firewall_update', 'save_data', 'cron');
        
        // Get update period for server
        $update_period = DNS::getRecord( 'securityfirewall-ttl-txt.cleantalk.org', true, DNS_TXT );
        $update_period = isset( $update_period['txt'] ) ? $update_period['txt'] : 0;
        $update_period = (int) $update_period > 43200 ?  (int) $update_period : 43200;
        Cron::updateTask( 'firewall_update', 'spbc_security_firewall_update__init', $update_period );
        
        return true;
    }
}

/**
 * @param $api_key
 * @param $updating_id
 *
 * @return array|bool|string|string[]
 * @throws Exception
 */
function spbc_security_firewall_update__get_multifiles( $api_key, $updating_id ){
    
    $result = FW::firewall_update__get_multifiles( $api_key );
    
    if( ! empty( $result['error'] ) ){
        return array( 'error' => 'GET MULTIFILE: ' . $result['error'] );
    }
    
    $rc_result = Helper::http__request__rc_to_host(
        'update_security_firewall__worker',
        array(
            'multifile_url'    => str_replace( array( 'http://', 'https://' ), '', $result['multifile_url'] ),
            'url_count'        => count( $result['file_urls'] ),
            'current_file_num' => 0,
            'updating_id'      => $updating_id,
        ),
        array( 'async' )
    );
    
    if( ! empty( $rc_result['error'] ) ){
        
        if( strpos( $rc_result['error'], 'WRONG_SITE_RESPONSE' ) !== false ){
            return spbc_security_firewall_update__worker(
                $updating_id,
                str_replace( array( 'http://', 'https://' ), '', $result['multifile_url'] ),
                count( $result['file_urls'] ),
                0
            );
        }
        
        return array( 'error' => 'GET MULTIFILE: ' . $result['error'] );
    }
    
    return $rc_result;
}

/**
 * @param $multifile_url
 * @param $url_count
 * @param $current_file_num
 * @param $updating_id
 *
 * @return array|bool|string|string[]
 * @throws Exception
 */
function spbc_security_firewall_update__process_file( $multifile_url, $url_count, $current_file_num, $updating_id ){
    
    $result = FW::update__write_to_db(
        DB::getInstance(),
        SPBC_TBL_FIREWALL_DATA . '_temp', // Write to the main table for daughter blogs
        SPBC_TBL_FIREWALL_DATA__IPS . '_temp',
        SPBC_TBL_FIREWALL_DATA__COUNTRIES . '_temp',
        'https://' . str_replace( 'multifiles', $current_file_num, $multifile_url )
    );
    
    if( ! empty( $result['error'] ) ){
        return array( 'error' => 'PROCESS FILE: ' . $result['error'] );
    }
    
    // Trying to make a remote call
    $rc_result = Helper::http__request__rc_to_host(
        'update_security_firewall__worker',
        array(
            'multifile_url'    => str_replace( array( 'http://', 'https://' ), '', $multifile_url ),
            'url_count'        => $url_count,
            'current_file_num' => $current_file_num + 1,
            'updating_id'      => $updating_id,
        ),
        array( 'async' )
    );
    
    if( ! empty( $rc_result['error'] ) ){
        
        // If test returned wrong response, call it current flow
        if( strpos( $rc_result['error'], 'WRONG_SITE_RESPONSE' ) !== false ){
            return spbc_security_firewall_update__worker(
                $updating_id,
                str_replace( array( 'http://', 'https://' ), '', $multifile_url ),
                $url_count,
                $current_file_num + 1
            );
        }
        
        return array( 'error' => 'PROCESS FILE: ' . $result['error'] );
    }
    
    return $rc_result;
}

/**
 * @param $multifile_url
 * @param $updating_id
 *
 * @return array|bool|string|string[]
 * @throws Exception
 */
function spbc_security_firewall_update__process_exclusions( $multifile_url, $updating_id ){
    
    $result = FW::update__write_to_db__exclusions(
        DB::getInstance(),
        SPBC_TBL_FIREWALL_DATA__IPS . '_temp'
    );
    
    if( ! empty( $result['error'] ) ){
        return array( 'error' => 'EXCLUSIONS: ' . $result['error'] );
    }
    
    $rc_result = Helper::http__request__rc_to_host(
        'update_security_firewall__worker',
        array(
            'multifile_url' => str_replace( array( 'http://', 'https://' ), '', $multifile_url ),
            'updating_id'   => $updating_id,
        ),
        array( 'async' )
    );
    
    if( ! empty( $rc_result['error'] ) ){
        
        // If test returned wrong response, call it current flow
        if( strpos( $rc_result['error'], 'WRONG_SITE_RESPONSE' ) !== false ){
            return spbc_security_firewall_update__worker(
                $updating_id,
                str_replace( array( 'http://', 'https://' ), '', $multifile_url )
            );
        }
        
        return array( 'error' => 'EXCLUSIONS: ' . $result['error'] );
    }
    
    return $rc_result;
}