<?php

namespace CleantalkSP\SpbctWP\Firewall;

use CleantalkSP\SpbctWP\Helper;
use CleantalkSP\Variables\Get;
use CleantalkSP\Variables\Post;
use CleantalkSP\Variables\Server;
use SpbcScannerH;

class WAF extends \CleantalkSP\SpbctWP\Firewall\FirewallModule {
	
	public $module_name = 'WAF';
	
	protected $waf_xss_check     = false;
	protected $waf_sql_check     = false;
	protected $waf_file_check    = false;
	protected $waf_exploit_check = false;
	
	private $waf_pattern       = array(); // Why WAF is triggered (reason)
	
	private $waf_sql_patterns = array();
	private $waf_exploit_patterns = array();
	private $waf_xss_patterns = array();
	
	public $waf_file_mime_check = array(
		'text/x-php',
		'text/plain',
		'image/x-icon',
	);
	
	/**
	 * FireWall_module constructor.
	 * Use this method to prepare any data for the module working.
	 *
	 * @param array $params
	 */
	public function __construct( $params = array() ){
		
		parent::__construct( $params );
		
	}
	
	/**
	 * Use this method to execute main logic of the module.
	 * @return mixed
	 */
	public function check() {
		
		$results = array();
		
		// Get signatures from DB
		$signatures = $this->db->fetch_all('SELECT * FROM '. SPBC_TBL_SCAN_SIGNATURES . ' WHERE type = "WAF_RULE";', ARRAY_A);
		
		if ( $signatures ) {
			
			foreach ( $signatures as $signature ) {
				
				switch ( $signature['attack_type'] ) {
					
					case 'SQL_INJECTION':
						$this->waf_sql_patterns[] = $signature['body'];
						break;
					case 'XSS':
						$this->waf_xss_patterns[] = $signature['body'];
						break;
					case 'EXPLOIT':
						$this->waf_exploit_patterns[] = $signature['body'];
						break;
				}
			}
		}
		
		// XSS
		if( $this->waf_xss_check ){
			if($this->waf_xss_check($_POST) || $this->waf_xss_check($_GET) || $this->waf_xss_check($_COOKIE)){
				$results[] = array('ip' => end($this->ip_array), 'is_personal' => false, 'status' => 'DENY_BY_WAF_XSS', 'pattern' => $this->waf_pattern);
			}
		}
		
		// SQL-injection
		if( $this->waf_sql_check ){
			if($this->waf_sql_check($_POST) || $this->waf_sql_check($_GET)){
				$results[] = array('ip' => end($this->ip_array), 'is_personal' => false, 'status' => 'DENY_BY_WAF_SQL', 'pattern' => $this->waf_pattern);
			}
		}
		
		// File
		if ($this->waf_file_check ){
			if($this->waf_file_check()){
				$results[] = array('ip' => end($this->ip_array), 'is_personal' => false, 'status' => 'DENY_BY_WAF_FILE', 'pattern' => $this->waf_pattern);
			}
		}
		
		// Exploits
		if( $this->waf_exploit_check ){
			if($this->waf_exploit_check()){
				$results[] = array('ip' => end($this->ip_array), 'is_personal' => false, 'status' => 'DENY_BY_WAF_EXPLOIT', 'pattern' => $this->waf_pattern);
			}
		}
		
		return $results;
		
	}
	
	/**
	 * Checks array for XSS-attack patterns
	 *
	 * @param $arr
	 *
	 * @return bool
	 */
	private function waf_xss_check( $arr ) {
		
		foreach( $arr as $name => $param ){
			
			// Recursion
			if( is_array( $param ) ){
				$result = $this->waf_xss_check( $param );
				if( $result === true )
					return true;
				continue;
			}
			
			//Check
			foreach( $this->waf_xss_patterns as $pattern ){
				/** @todo add regexp check  */
				if( stripos( $param, $pattern ) !== false ){
					$this->waf_pattern = array( 'critical' => $pattern );
					return true;
				}
			}
		}
		
		return false;
		
	}
	
	/**
	 * Checks array for SQL injections
	 *
	 * @param $arr
	 *
	 * @return bool
	 */
	private function waf_sql_check( $arr ) {
		
		foreach( $arr as $name => $param ){
			
			if( is_array( $param ) ){
				$result = $this->waf_sql_check( $param );
				if( $result === true )
					return true;
				continue;
			}
			
			foreach( $this->waf_sql_patterns as $pattern ){
				if( @ preg_match('/'.$pattern.'/i', $param) === 1 ){
					$this->waf_pattern = array( 'critical' =>  $pattern );
					return true;
				}
			}
		}
		
		return false;
		
	}
	
	/**
	 * Checks $_SERVER['QUERY_STRING'] for exploits
	 *
	 * @return bool
	 */
	private function waf_exploit_check() {
		
		foreach( $this->waf_exploit_patterns as $pattern ){
			if( @ preg_match('/'.$pattern.'/i', Server::get('QUERY_STRING')) === 1 ){
				$this->waf_pattern = array( 'critical' =>  $pattern );
				return true;
			}
		}
		
		return false;
		
	}
	
	/**
	 * Checks uploaded files for malicious code
	 *
	 * @return boolean Does the file contain malicious code
	 */
	private function waf_file_check() {
		
		if( ! empty( $_FILES ) ){
			foreach( $_FILES as $filez ){
				if ( ( empty($filez['errror'] ) || $filez['errror'] == UPLOAD_ERR_OK ) ) {
					$filez['tmp_name'] = is_array( $filez['tmp_name'] ) ? $filez['tmp_name'] : array( $filez['tmp_name'] );
					foreach( $filez['tmp_name'] as $file ){
						if(
							is_string( $file ) &&
							is_uploaded_file( $file ) &&
							is_readable( $file ) &&
							in_array( Helper::get_mime_type( $file ), $this->waf_file_mime_check )
						) {
							$fileh = new SpbcScannerH( null, array( 'content' => file_get_contents( $file ) ) );
							if( empty( $fileh->error ) ){
								$fileh->process_file();
								if( ! empty( $fileh->verdict ) ){
									foreach( $fileh->verdict as $severity => $result ){
										$this->waf_pattern[$severity] = reset($result);
									}
									return true;
								}
							}
						}
					}
				}
			}
		}
		
		return false;
		
	}
	
	/**
	 * AJAX callback for details about latest blocked file
	 */
	public static function waf_file__get_last_blocked_info() {
		
		check_ajax_referer('spbc_secret_nonce', 'security');
		
		global $wpdb;
		
		$timestamp = intval(Post::get('timestamp'));
		
		// Select only latest ones.
		$result = $wpdb->get_results(
			'SELECT *'
			.' FROM '. SPBC_TBL_FIREWALL_LOG
			.' WHERE status = "DENY_BY_WAF_FILE" AND entry_timestamp > '.($timestamp - 2)
			.' ORDER BY entry_timestamp DESC LIMIT 1;'
			, OBJECT
		);
		
		if($result){
			$result = $result[0];
			$out = array(
				'blocked' => true,
				'warning' => __('Security by CleanTalk: File was blocked by Web Application FireWall.', 'security-malware-firewall'),
				'pattern_title' => __('Detected pattern: ', 'security-malware-firewall'),
				'pattern' => json_decode($result->pattern, true),
			);
		}else
			$out = array('blocked' => false);
		
		die(json_encode($out));
	}
	
	/**
	 * Shows DIE page.
	 * Stops script executing.
	 *
	 * @param $result
	 */
	public function _die( $result ){
		
		// Common actions for all modules
		parent::_die( $result );
		
		// Adding block reason
		switch( $result['status'] ){
			case 'DENY':                $reason = __('Blacklisted', 'security-malware-firewall');                      break;
			case 'DENY_BY_NETWORK':	    $reason = __('Hazardous network', 'security-malware-firewall');	               break;
			case 'DENY_BY_DOS':         $reason = __('Blocked by DoS prevention system', 'security-malware-firewall'); break;
			case 'DENY_BY_WAF_XSS':	    $reason = __('Blocked by Web Application Firewall: XSS attack detected.',    'security-malware-firewall'); break;
			case 'DENY_BY_WAF_SQL':	    $reason = __('Blocked by Web Application Firewall: SQL-injection detected.', 'security-malware-firewall'); break;
			case 'DENY_BY_WAF_EXPLOIT':	$reason = __('Blocked by Web Application Firewall: Exploit detected.',       'security-malware-firewall'); break;
			case 'DENY_BY_WAF_FILE':    $reason = __('Blocked by Web Application Firewall: Malicious files upload.', 'security-malware-firewall'); break;
			case 'DENY_BY_BFP':         $reason = __('Blocked by BruteForce Protection: Too many invalid logins.',   'security-malware-firewall'); break;
			default :                   $reason = __('Blacklisted', 'security-malware-firewall');                      break;
		}
		
		if( $this->die_page__file ){
			
			$die_page_template = file_get_contents($this->die_page__file );

            $status = $result['status'] == 'PASS_SFW__BY_WHITELIST' ? '1' : '0';
            $cookie_val = md5( $result['ip'] . $this->api_key ) . $status;

			// Translation
			$replaces = array(
				'{TITLE}' => __('Blocked: Security by CleanTalk', 'security-malware-firewall'),
				'{TEST_TITLE}' => Get::get('spbct_test')
					? __('This is the testing page for Security FireWall', 'security-malware-firewall')
					: '',
				'{REASON}' => $reason,
				'{GENERATED_TIMESTAMP}' => time(),
				'{FALSE_POSITIVE_WARNING}' => __('Maybe you\'ve been blocked by a mistake. Please refresh the page (press CTRL + F5) or try again later.', 'security-malware-firewall'),
				
				
				'{REMOTE_ADDRESS}'                 => $result['ip'],
				'{SERVICE_ID}'                     => $this->state->data['service_id'],
				'{HOST}'                           => Server::get( 'HTTP_HOST' ),
				'{GENERATED}'                      => '<h2 class="second">The page was generated at '.date("D, d M Y H:i:s"). '</h2>',
			);
			
			foreach( $replaces as $place_holder => $replace ){
				$die_page_template = str_replace( $place_holder, $replace, $die_page_template );
			}
			
			wp_die($die_page_template, "Blacklisted", Array('response'=>403));
			
		}else{
			wp_die("IP BLACKLISTED. Blocked by Security Firewall " . $result['ip'], "Blacklisted", Array('response'=>403));
		}
		
	}
}