<?php

namespace CleantalkSP\SpbctWP\HTTP;

use CleantalkSP\SpbctWP\Helpers\IP;
use CleantalkSP\SpbctWP\State;

class CDNHeadersChecker
{
    private static $current_cdn_check_result = array();

    private static $limit_of_cdn_records_to_keep = 10;

    public static function check()
    {
        global $spbc;
        $result = array(
            'found_headers' => null,
            'setting_changed_to' => null,
            'error' => null
        );
        try {
            $old_setting = $spbc->settings['wp__use_builtin_http_api'];
            $spbc->settings['wp__use_builtin_http_api'] = 0;
            $self_url = is_multisite() ? get_blog_option(0, 'home') : get_option('home');
            $provided_headers =  self::getResponseHeadersNames($self_url);
            $known_cdn_headers = IP::getKnownCDNHeadersNames();
            $found_headers = self::findKnownCDNHeaders($provided_headers, $known_cdn_headers);
            $result['found_headers'] = $found_headers;
            $last_check_headers = self::getLastCheckCDNHeaders();
            $new_header_id = self::getNewHeaderIdForSettings($spbc, $last_check_headers);
            if ($new_header_id) {
                $result['setting_changed_to'] = $new_header_id;
                self::applyIPGetHeadersSettings($spbc, $new_header_id);
            }
            self::updateStoredCDNHeadersData($found_headers, $new_header_id);
            $spbc->settings['wp__use_builtin_http_api'] = $old_setting;
        } catch (\Exception $e) {
            $result['error'] = $e;
        }
        return $result;
    }

    private static function getResponseHeadersNames($self_url)
    {
        $http = new Request();
        return  $http
            ->setUrl($self_url)
            ->setPresets('get_headers nocache')
            ->request();
    }

    private static function findKnownCDNHeaders($provided_headers, $known_cdn_headers)
    {
        $headers = array();
        foreach ($provided_headers as $provided_header) {
            $provided_header = strtolower($provided_header);
            foreach ($known_cdn_headers as $known_header) {
                if (stripos($provided_header, $known_header) !== false) {
                    $headers[] = $known_header;
                }
            }
        }
        return $headers;
    }

    private static function saveStoredCDNHeadersData()
    {
        global $spbc;
        $spbc->data['allowed_cdn_headers_data'] = serialize(self::$current_cdn_check_result);
        $spbc->save('data');
    }

    private static function loadStoredCDNHeadersData()
    {
        global $spbc;
        $stored_cdn_headers_data = isset($spbc->data['allowed_cdn_headers_data'])
            ? $spbc->data['allowed_cdn_headers_data']
            : array();
            return unserialize($stored_cdn_headers_data);
    }

    private static function updateStoredCDNHeadersData($found_headers, $new_header_id)
    {
        $new_header_id = !empty($new_header_id) ? $new_header_id : null;

        self::$current_cdn_check_result = self::loadStoredCDNHeadersData();
        if (is_array(self::$current_cdn_check_result)) {
            if (count(self::$current_cdn_check_result) >= self::$limit_of_cdn_records_to_keep) {
                array_shift(self::$current_cdn_check_result);
            }
        }

        self::$current_cdn_check_result[] = array(
            'time' => time(),
            'found_cdn_headers' => $found_headers,
            'setting_changed_to' => $new_header_id,
        );

        self::saveStoredCDNHeadersData();
    }

    private static function getLastCheckCDNHeaders()
    {
        $data = self::loadStoredCDNHeadersData();
        if (count($data)) {
            return !empty($data[count($data) - 1]['found_cdn_headers'])
                ? $data[count($data) - 1]['found_cdn_headers']
                : array();
        }
        return array();
    }

    private static function getNewHeaderIdForSettings(State $spbc, $last_check_headers)
    {
        $last_check_header = isset($last_check_headers[0]) ? $last_check_headers[0] : null;
        $new_header_id = null;
        if (!$last_check_header) {
            //set remote addr (2) as source if nothing found
            if (!isset($spbc->settings['secfw__get_ip']) || $spbc->settings['secfw__get_ip'] !== '2') {
                $new_header_id = '2';
            }
        } else {
            $new_header_id = IP::getHeaderIDbySlug($last_check_header);
        }

        return $new_header_id;
    }

    private static function applyIPGetHeadersSettings(State $spbc, $new_header_id = null)
    {
        $spbc->data['secfw__get_ip__last_auto_set'] = serialize(array(
            'time' => time(),
            'header_id' => $new_header_id,
            'setting_name' => IP::$known_headers[$new_header_id]['name'],
            'header_slug' => IP::$known_headers[$new_header_id]['slug'],
        ));
        $spbc->save('data');

        $spbc->settings['secfw__get_ip'] = (string)$new_header_id;
        $spbc->save('settings');
        return $spbc;
    }

    public static function getSummaryBlockHTML()
    {
        global $spbc;

        //collect data
        $stored_checks_data = self::loadStoredCDNHeadersData();

        //build layout template rows
        $rows = '';
        foreach ($stored_checks_data as $check) {
            $__headers_text = !empty($check['found_cdn_headers'])
                ? __('Found headers:', 'security_malware_firewall') . ' ' . implode(',', $check['found_cdn_headers'])
                : __('No known CDN headers found', 'security_malware_firewall');
            $__time_text = date('Y-m-d h:i:s', (int)($check['time']));
            $__new_setting_state_text = !empty($check['setting_changed_to'])
                ? __('Set new source to ', 'security_malware_firewall') . '<b>' . IP::$known_headers[$check['setting_changed_to']]['slug'] . '</b>'
                : 'No changes';
            $rows .= '
            <tr>
                <td class="wp-tab-panel">
                ' . $__time_text . '
                </td>
                <td class="wp-tab-panel">
                ' . $__headers_text . '
                </td>
                <td class="wp-tab-panel">
                ' . $__new_setting_state_text . '
                </td>
            </tr>
            ';
        }

        //build text locales
        $__header = __('Automatic HTTP Headers Detection results (click to show)', 'security_malware_firewall');
        $__check_result_h = __('Check result', 'security_malware_firewall');
        $__check_time_h = __('Check time', 'security_malware_firewall');
        $__source_changes = __('Source changes', 'security_malware_firewall');
        $__header_slug_text = !empty($spbc->settings['secfw__get_ip'])
            ? '<b>' . IP::$known_headers[$spbc->settings['secfw__get_ip']]['slug'] . '</b>'
            : __('unknown statement', 'security_malware_firewall');
        $__current_source = __("Current IP source is set to", 'security_malware_firewall') . ' ' . $__header_slug_text;

        //build template
        $html = '
        <div>
            <a href="#" onclick="spbcSummaryShowCDNCheckerTable()">
            ' . $__header . '
            </a>
            <table id="spbc_stats_cdn_checker_table" class="wp-tab-panel" style="display: none; width: max-content">
                <tbody>
                    <tr>
                        <th class="wp-tab-panel">
                        ' . $__check_time_h . '
                        </th>
                        <th class="wp-tab-panel">
                        ' . $__check_result_h . '
                        </th>
                        <th class="wp-tab-panel">
                        ' . $__source_changes . '
                        </th>
                    </tr>
                    ' . $rows . '
                    <tr>
                        <td colspan="3">
                        </td>
                    </tr>
                    <tr style="text-align: center">
                        <td class="wp-tab-panel" colspan="3">
                        ' . $__current_source . '
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>';

        return $html;
    }

    public static function getDescriptionText()
    {
        return __('Enable this option to set IP address source manually. If disabled, the plugin will detect IP source via self-call. Stats can be seen on the "Summary" tab', 'security-malware-firewall');
    }

    public static function getDescriptionLongTexts()
    {
        return array(
        'title' => __('Get IP from additional headers', 'security-malware-firewall'),
        'desc'  => __('If the source header is selected, the plugin will search IP address in this header. If nothing found there, the plugin will run automatic search for every known possible IP sources.', 'security-malware-firewall'),
        );
    }
}
