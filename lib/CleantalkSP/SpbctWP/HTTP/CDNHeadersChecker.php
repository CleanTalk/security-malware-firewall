<?php

namespace CleantalkSP\SpbctWP\HTTP;

use CleantalkSP\SpbctWP\Helpers\HTTP;
use CleantalkSP\SpbctWP\Helpers\IP;
use CleantalkSP\SpbctWP\State;

class CDNHeadersChecker
{
    private static $current_cdn_check_result = array();

    private static $limit_of_cdn_records_to_keep = 3;

    public static function check()
    {
        global $spbc;
        $result = array(
            'found_headers' => null,
            'setting_changed_to' => null,
            'error' => null
        );
        try {
            $old_setting = $spbc->settings['wp__use_builtin_http_api'];
            $spbc->settings['wp__use_builtin_http_api'] = 0;
            $self_url = is_multisite() ? get_blog_option(null, 'home') : get_option('home');
            $provided_headers =  self::getResponseHeadersNames($self_url);
            $known_cdn_headers = IP::getKnownCDNHeadersNames();
            $found_headers = self::findKnownCDNHeaders($provided_headers, $known_cdn_headers);
            $result['found_headers'] = $found_headers;
            self::updateStoredCDNHeadersData($found_headers);
            $last_check_headers = self::getLastCheckCDNHeaders();
            $new_header_id = self::getNewHeaderIdForSettings($spbc, $last_check_headers);
            if ($new_header_id) {
                $result['setting_changed_to'] = $new_header_id;
                self::applyIPGetHeadersSettings($spbc, $new_header_id);
            }
            $spbc->settings['wp__use_builtin_http_api'] = $old_setting;
        } catch (\Exception $e) {
            $result['error'] = $e;
        }
        return $result;
    }

    private static function getResponseHeadersNames($self_url)
    {
        return array_keys(HTTP::getHTTPHeaders());
    }

    private static function findKnownCDNHeaders($provided_headers, $known_cdn_headers)
    {
        $headers = array();
        foreach (array_keys($provided_headers) as $provided_header) {
            $provided_header = strtolower($provided_header);
            foreach ($known_cdn_headers as $known_header) {
                if (stripos($provided_header, $known_header) !== false) {
                    $headers[] = $known_header;
                }
            }
        }
        return $headers;
    }

    private static function saveStoredCDNHeadersData()
    {
        global $spbc;
        $spbc->data['allowed_cdn_headers_data'] = serialize(self::$current_cdn_check_result);
        $spbc->save('data');
    }

    private static function loadStoredCDNHeadersData()
    {
        global $spbc;
        $stored_cdn_headers_data = isset($spbc->data['allowed_cdn_headers_data'])
            ? $spbc->data['allowed_cdn_headers_data']
            : array();
            return unserialize($stored_cdn_headers_data);
    }

    private static function updateStoredCDNHeadersData($found_headers)
    {
        self::$current_cdn_check_result = self::loadStoredCDNHeadersData();
        if (is_array(self::$current_cdn_check_result)) {
            if (count(self::$current_cdn_check_result) >= self::$limit_of_cdn_records_to_keep) {
                array_shift(self::$current_cdn_check_result);
            }
        }

        self::$current_cdn_check_result[] = array(
            'time' => time(),
            'found_cdn_headers' => $found_headers
        );

        self::saveStoredCDNHeadersData();
    }

    private static function getLastCheckCDNHeaders()
    {
        $data = self::loadStoredCDNHeadersData();
        if (count($data)) {
            return !empty($data[count($data) - 1]['found_cdn_headers'])
                ? $data[count($data) - 1]['found_cdn_headers']
                : array();
        }
        return array();
    }

    private static function getNewHeaderIdForSettings(State $spbc, $last_check_headers)
    {
        $last_check_header = isset($last_check_headers[0]) ? $last_check_headers[0] : null;
        $new_header_id = null;
        if (!$last_check_header) {
            //set remote addr (2) as source if nothing found
            if (!isset($spbc->settings['secfw__get_ip']) || $spbc->settings['secfw__get_ip'] !== '2') {
                $new_header_id = '2';
            }
        } else {
            $new_header_id = IP::getHeaderIDbySlug($last_check_header);
        }

        return $new_header_id;
    }

    private static function applyIPGetHeadersSettings(State $spbc, $new_header_id = null)
    {
        $spbc->data['secfw__get_ip__last_auto_set'] = serialize(array(
            'time' => time(),
            'header_id' => $new_header_id,
            'setting_name' => IP::$known_headers[$new_header_id]['name'],
            'header_slug' => IP::$known_headers[$new_header_id]['slug'],
        ));
        $spbc->save('data');

        $spbc->settings['secfw__get_ip'] = (string)$new_header_id;
        $spbc->save('settings');
        return $spbc;
    }

    public static function getSummaryBlockHTML()
    {
        global $spbc;
        //collect data
        $last_settings_change = array();
        if (!empty($spbc->data['secfw__get_ip__last_auto_set'])) {
            $last_settings_change = unserialize($spbc->data['secfw__get_ip__last_auto_set']);
        }
        $stored_checks_data = self::loadStoredCDNHeadersData();
        $header_slug_text = !empty($spbc->settings['secfw__get_ip'])
            ? '<b>' . IP::$known_headers[$spbc->settings['secfw__get_ip']]['slug'] . '</b>'
            : __('unknown statement', 'security_malware_firewall');

        //build layout
        $html = '<div>';
        $html .= '<a href="#" onclick="spbcSummaryShowCDNCheckerTable()">';
        $html .= __('Automatic HTTP Headers Detection results (click to show)', 'security_malware_firewall');
        $html .= '</a>';
        $html .= '<table id="spbc_stats_cdn_checker_table" style="border: 1px dotted gray; display: none;">';
        $html .= '<tbody>';
        $html .= '<tr>';
        $html .= '<th>';
        $html .= __('Check time', 'security_malware_firewall');
        $html .= '</th>';
        $html .= '<th>';
        $html .= __('Check result', 'security_malware_firewall');
        $html .= '</th>';
        $html .= '</tr>';

        //build rows
        foreach ($stored_checks_data as $check) {
            $headers_text = !empty($check['found_cdn_headers'])
                ? __('Found headers:', 'security_malware_firewall') . ' ' . implode(',', $check['found_cdn_headers'])
                : __('No known CDN headers found', 'security_malware_firewall');
            $time_text = date('Y-m-d h:i:s', (int)($check['time']));
            $html .= '<tr>';
            $html .= '<td>';
            $html .= $time_text;
            $html .= '</td>';
            $html .= '<td>';
            $html .= $headers_text;
            $html .= '</td>';
            $html .= '</tr>';
        }

        $html .= '<tr>';
        $html .= '<td colspan="2">';
        $html .= __("Current IP source is set to", 'security_malware_firewall') . ' ' . $header_slug_text;

        if (!empty($last_settings_change)) {
            $time_text = !empty($last_settings_change['time'])
                ? date('Y-m-d h:i:s', (int)($last_settings_change['time'] + $spbc->data['site_utc_offset_in_seconds'] ))
                : 'unknown datetime';

            $html .= __(", last change was set on", 'security_malware_firewall') . ' ' . $time_text;
        }

        $html .= '</td>';
        $html .= '</tr>';

        $html .= '</tbody>';
        $html .= '</table>';
        $html .= '</div>';

        return $html;
    }

    public static function getDescriptionText()
    {
        return __('Enable this option to set IP address source manually. If disabled, the plugin will detect IP source via self-call. Stats can be seen on the "Summary" tab', 'security-malware-firewall');
    }
}
