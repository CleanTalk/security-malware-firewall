<?php

namespace CleantalkSP\SpbctWP\Scanner\Stages;

use CleantalkSP\SpbctWP\API;
use CleantalkSP\SpbctWP\Cron;
use CleantalkSP\SpbctWP\RemoteCalls;
use CleantalkSP\SpbctWP\Scanner\Frontend;
use CleantalkSP\SpbctWP\Scanner\ScanningLog\ScanningLogFacade;
use CleantalkSP\Variables\Request;
use CleantalkSP\SpbctWP\Scanner\Stages\Repositories\CriticalRepository;
use CleantalkSP\SpbctWP\Scanner\Stages\Repositories\LinksRepository;
use CleantalkSP\SpbctWP\Scanner\Stages\Repositories\SuspiciousRepository;
use CleantalkSP\SpbctWP\Scanner\Stages\Repositories\UnknownRepository;
use CleantalkSP\SpbctWP\Scanner\Surface;

class SendResultsStage
{
    /**
     * @var DB
     */
    protected $spbc;

    /**
     * @var DB
     */
    protected $wpdb;

    public function __construct()
    {
        global $spbc, $wpdb;

        $this->wpdb = $wpdb;
        $this->spbc = $spbc;
    }

    public function execute()
    {
        global $spbc;

        $error = '';

        $critical = new CriticalRepository();
        $critical_files_found = $critical->getResultData();

        $suspicious = new SuspiciousRepository();
        $suspicious_files_found = $suspicious->getResultData();

        $unknown = new UnknownRepository();
        $unknown_files_found = $unknown->getResultData();

        $result = $this->sendFiles($critical_files_found, $suspicious_files_found, $unknown_files_found);

        ray($result);
        if ( ! empty($result['error']) ) {
            $error = 'Common result send: ' . $result['error'];
        } else {
            $spbc->data['scanner']['last_sent'] = current_time('timestamp');
            $spbc->data['scanner']['last_scan'] = current_time('timestamp');
            $spbc->data['scanner']['scan_finish_timestamp'] = time();
            $spbc->data['scanner']['last_scan_amount'] = Request::get('total_scanned') ?: $this->getTotalScanned();
            $spbc->data['scanner']['signatures_found'] = []; // Clearing ids of the signatures found
        }

        $links = new LinksRepository();
        $error = $links->handle($error);

        $error = $this->sendBackup($error);

        $error = $this->sendFrontend($error);

        $spbc->error_toggle((bool)$error, 'scanner_result_send', $error);

        $this->updateAutoStart();

        $spbc->save('data');

        $duration_of_scanning = $this->updateLog();

        $out = array(
            'end' => 1,
            'stage_data_for_logging' => array(
                'title' => $duration_of_scanning,
                'description' => ''
            )
        );

        if ((bool)$error) {
            $out['error'] = $error;
        }

        return $out;
    }

    private function sendFiles($critical_files_found, $suspicious_files_found, $unknown_files_found)
    {
        $result = API::method__security_mscan_logs(
            $this->spbc->settings['spbc_key'],
            (int)$this->spbc->settings['scanner__list_unknown'],
            $this->spbc->service_id,
            $this->getScannerStartLocalDate(),
            $this->getScannerResult(),
            $this->getTotalCoreFiles(),
            $this->getTotalSiteFiles(),
            $critical_files_found,
            $suspicious_files_found,
            $unknown_files_found,
            RemoteCalls::check() ? 'auto' : 'manual',
            $this->getChecksumCountCT(),
            $this->getChecksumCountUser(),
            $this->getSignaturesCount(),
            $this->getTotalScanned(),
            isset($this->spbc->data['scanner']['total_site_pages']) ? $this->spbc->data['scanner']['total_site_pages'] : 0,
            isset($this->spbc->data['scanner']['scanned_site_pages']) ? $this->spbc->data['scanner']['scanned_site_pages'] : 0,
            $this->getSignaturesFound()
        );

        return $result;
    }

    private function getScannerStartLocalDate()
    {
        return isset($this->spbc->data['scanner']['scanner_start_local_date'])
            ? $this->spbc->data['scanner']['scanner_start_local_date']
            : current_time('Y-m-d H:i:s');
    }

    private function getScannerResult()
    {
        return !empty($critical_files_found) || !empty($suspicious_files_found) ? 'warning' : 'passed';
    }

    private function getTotalCoreFiles()
    {
        $total = (int)$this->wpdb->get_var(
            'SELECT COUNT(*) FROM ' . SPBC_TBL_SCAN_FILES . ' WHERE source_type = "CORE" AND source = "wordpress"'
        );

        return $total ?: 0;
    }

    private function getTotalSiteFiles()
    {
        return $this->spbc->data['scanner']['files_total'] = $this->countFileSystem()['total'];
    }

    private function getChecksumCountCT()
    {
        return isset($this->spbc->data['scanner']['checksums_count_ct']) ? $this->spbc->data['scanner']['checksums_count_ct'] : null;
    }

    private function getChecksumCountUser()
    {
        return (int)$this->wpdb->get_var(
            'SELECT COUNT(*) from ' . SPBC_TBL_SCAN_FILES . ' WHERE status = "APPROVED_BY_USER"'
        );
    }

    private function getSignaturesFound()
    {
        $signatures = isset($this->spbc->data['scanner']['signatures_found']) ? $this->spbc->data['scanner']['signatures_found'] : [];

        return json_encode($signatures);
    }

    private function getSignaturesCount()
    {
        $found = $this->getSignaturesFound();
        $signatures = isset($this->spbc->data['scanner']['signature_count']) ? $this->spbc->data['scanner']['signature_count'] : null;
        if ( is_null($signatures) && is_string($found) ) {
            return count(json_decode($found, true));
        }

        return $signatures;
    }

    private function getTotalScanned()
    {
        return isset($this->spbc->data['scanner']['scanned_total']) ? $this->spbc->data['scanner']['scanned_total'] : null;
    }

    /**
     * @param string $path_to_scan
     *
     * @return array
     * @global State $spbc
     *
     */
    private function countFileSystem($path_to_scan = ABSPATH)
    {
        ini_set('max_execution_time', '120');

        $path_to_scan = realpath($path_to_scan);
        $init_params  = array(
            'count'           => true,
            'file_exceptions' => 'wp-config.php',
            'extensions'      => 'php, html, htm, js, php2, php3, php4, php5, php6, php7, phtml, shtml, phar, odf, [ot.]',
            'files_mandatory' => array(),
            'dir_exceptions'  => array(SPBC_PLUGIN_DIR . 'quarantine')
        );

        if ( ! empty($this->spbc->settings['scanner__dir_exclusions']) ) {
            $init_params['dir_exceptions'] = array_merge(
                $init_params['dir_exceptions'],
                spbc__get_exists_directories(explode("\n", $this->spbc->settings['scanner__dir_exclusions']))
            );
        }

        $scanner = new Surface($path_to_scan, realpath(ABSPATH), $init_params);

        return array(
            'total' => $scanner->files_count,
            'end'   => 1,
        );
    }

    private function sendBackup($error)
    {
        if ( $this->spbc->settings['scanner__auto_cure'] && ! empty($this->spbc->data['scanner']['cured']) ) {
            //todo This stuff should be refactored on cloud to use CureLog instance, at the moment this does not send failed files
            $result_repairs = API::method__security_mscan_repairs(
                $this->spbc->settings['spbc_key'],            // API key
                'SUCCESS',                    // Repair result
                'ALL_DONE',                // Repair comment
                (array)$this->spbc->data['scanner']['cured'], // Files
                count($this->spbc->data['scanner']['cured']), // Links found for last scan
                $this->spbc->data['scanner']['last_backup'],  // Last backup num
                $this->getScannerStartLocalDate()             // Scanner start local date
            );
            if ( ! empty($result_repairs['error']) ) {
                $error .= ' Repairs result send: ' . $result_repairs['error'];
            }
        }

        return $error;
    }

    private function sendFrontend($error)
    {
        if ( isset($this->spbc->settings['scanner__frontend_analysis']) && $this->spbc->settings['scanner__frontend_analysis'] ) {
            try {
                Frontend::sendFmsLogs();
            } catch (\Exception $exception) {
                $error .= $exception->getMessage();
            }
        }

        return $error;
    }

    private function updateAutoStart()
    {
        if ( $this->spbc->settings['scanner__auto_start'] && empty($this->spbc->errors['configuration']) ) {
            $scanner_launch_data = spbc_get_custom_scanner_launch_data();
            Cron::updateTask(
                'scanner__launch',
                'spbc_scanner__launch',
                $scanner_launch_data['period'],
                $scanner_launch_data['start_time']
            );
        }
    }

    private function updateLog()
    {
        $duration_of_scanning = __('The duration of the scan is not known', 'security-malware-firewall');
        if (isset($this->spbc->data['scanner']['scan_start_timestamp'], $this->spbc->data['scanner']['scan_finish_timestamp'])) {
            $duration_of_scanning = '<b>'
                . sprintf(__('Scan duration %s seconds.', 'security-malware-firewall')
                . '</b>', $this->spbc->data['scanner']['scan_finish_timestamp'] - $this->spbc->data['scanner']['scan_start_timestamp']) ;
        }

        ScanningLogFacade::writeToLog($duration_of_scanning);

        return $duration_of_scanning;
    }
}
