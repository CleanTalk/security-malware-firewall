<?php

namespace CleantalkSP\SpbctWP\Scanner\Stages;

use CleantalkSP\SpbctWP\Scanner\Stages\Repositories\CriticalRepository;
use CleantalkSP\SpbctWP\Scanner\Stages\Repositories\SuspiciousRepository;
use CleantalkSP\SpbctWP\Scanner\Stages\Repositories\UnknownRepository;

class SendResultsStage
{
    public function __construct()
    {
        // Constructor logic here
    }

    public function execute()
    {
        global $spbc, $wpdb;

        // Getting modified files
        $critical = new CriticalRepository();
        // $sql_result__critical = $critical->getResultData();
        $critical_files_found = $critical->getResultData();

        $suspicious = new SuspiciousRepository();
        // $sql_result__suspicious = $suspicious->getResultData();
        $suspicious_files_found = $suspicious->getResultData();

        // Getting unknown files
        $unknown = new UnknownRepository();
        $unknown_files_found = $unknown->getResultData();

        $error = '';

        /**
         * Getting parameters for security_mscan_logs()
         */
        $key                  = $spbc->settings['spbc_key'];
        $list_unknown         = (int)$spbc->settings['scanner__list_unknown'];
        $service_id           = $spbc->service_id;
        $scanner_start_local_date = isset($spbc->data['scanner']['scanner_start_local_date'])
            ? $spbc->data['scanner']['scanner_start_local_date']
            : current_time('Y-m-d H:i:s');
        $scan_result          = !empty($critical_files_found) || !empty($suspicious_files_found) ? 'warning' : 'passed';
        $total_site_files     = $spbc->data['scanner']['files_total'] = $this->countFileSystem()['total'];
        $scan_type            = RemoteCalls::check() ? 'auto' : 'manual';
        $checksums_count_ct   = isset($spbc->data['scanner']['checksums_count_ct']) ? $spbc->data['scanner']['checksums_count_ct'] : null;
        $checksums_count_user = (int)$wpdb->get_var(
            'SELECT COUNT(*) from ' . SPBC_TBL_SCAN_FILES . ' WHERE status = "APPROVED_BY_USER"'
        );
        $signatures_count     = isset($spbc->data['scanner']['signature_count']) ? $spbc->data['scanner']['signature_count'] : null;
        $scanned_total        = isset($spbc->data['scanner']['scanned_total']) ? $spbc->data['scanner']['scanned_total'] : null;
        $total_site_pages     = isset($spbc->data['scanner']['total_site_pages']) ? $spbc->data['scanner']['total_site_pages'] : 0;
        $scanned_site_pages   = isset($spbc->data['scanner']['scanned_site_pages']) ? $spbc->data['scanner']['scanned_site_pages'] : 0;
        $total_core_files = (int)$wpdb->get_var(
            'SELECT COUNT(*) FROM ' . SPBC_TBL_SCAN_FILES . ' WHERE source_type = "CORE" AND source = "wordpress"'
        );
        $total_core_files = $total_core_files ?: 0;
        $signatures_found = isset($spbc->data['scanner']['signatures_found']) ? $spbc->data['scanner']['signatures_found'] : [];
        $signatures_found = json_encode($signatures_found);

        if ( is_null($signatures_count) && is_string($signatures_found) ) {
            $signatures_count = count(json_decode($signatures_found, true));
        }

        // API. Sending files scan result
        $result = API::method__security_mscan_logs(
            $key,
            $list_unknown,
            $service_id,
            $scanner_start_local_date,
            $scan_result,
            $total_core_files,
            $total_site_files,
            $critical_files_found,
            $suspicious_files_found,
            $unknown_files_found,
            $scan_type,
            $checksums_count_ct,
            $checksums_count_user,
            $signatures_count,
            $scanned_total,
            $total_site_pages,
            $scanned_site_pages,
            $signatures_found
        );

        if ( ! empty($result['error']) ) {
            $error = 'Common result send: ' . $result['error'];
        } else {
            $spbc->data['scanner']['last_sent']        = current_time('timestamp');
            $spbc->data['scanner']['last_scan']        = current_time('timestamp');
            $spbc->data['scanner']['scan_finish_timestamp'] = time();
            $spbc->data['scanner']['last_scan_amount'] = Request::get('total_scanned') ?: $scanned_total;
            $spbc->data['scanner']['signatures_found'] = []; // Clearing ids of the signatures found
        }

        // Sending links scan result
        if ( $spbc->settings['scanner__outbound_links'] ) {
            $links         = $this->db->fetchAll(
                'SELECT `link`, `link_text`, `page_url`'
                . ' FROM ' . SPBC_TBL_SCAN_LINKS
                . ' WHERE scan_id = (SELECT MAX(scan_id) FROM ' . SPBC_TBL_SCAN_LINKS . ');',
                OBJECT
            );
            $links_to_send = array();
            foreach ( $links as $link ) {
                $links_to_send[$link->link] = array(
                    'link_text'   => $link->link_text,
                    'page_url'    => $link->page_url,
                );
            }
            $links_count   = sizeof($links_to_send);
            $links_to_send = json_encode($links_to_send);

            $result_links = API::method__security_linksscan_logs(
                $spbc->settings['spbc_key'],
                $scanner_start_local_date,
                $links_count ? 'failed' : 'passed',
                $links_count,
                $links_to_send
            );
            if ( ! empty($result_links['error']) ) {
                $error .= ' Links result send: ' . $result_links['error'];
            } else {
                $spbc->data['scanner']['last_scan_links_amount'] = $links_count;
            }
        }

        // Sending info about backup
        if ( $spbc->settings['scanner__auto_cure'] && ! empty($spbc->data['scanner']['cured']) ) {
            //todo This stuff should be refactored on cloud to use CureLog instance, at the moment this does not send failed files
            $result_repairs = API::method__security_mscan_repairs(
                $spbc->settings['spbc_key'],            // API key
                'SUCCESS',                    // Repair result
                'ALL_DONE',                // Repair comment
                (array)$spbc->data['scanner']['cured'], // Files
                count($spbc->data['scanner']['cured']), // Links found for last scan
                $spbc->data['scanner']['last_backup'],  // Last backup num
                $scanner_start_local_date               // Scanner start local date
            );
            if ( ! empty($result_repairs['error']) ) {
                $error .= ' Repairs result send: ' . $result_repairs['error'];
            }
        }

        // Frontend analysis
        if ( isset($spbc->settings['scanner__frontend_analysis']) && $spbc->settings['scanner__frontend_analysis'] ) {
            try {
                Frontend::sendFmsLogs();
            } catch (\Exception $exception) {
                $error .= $exception->getMessage();
            }
        }

        $spbc->error_toggle((bool)$error, 'scanner_result_send', $error);

        if ( $spbc->settings['scanner__auto_start'] && empty($spbc->errors['configuration']) ) {
            $scanner_launch_data = spbc_get_custom_scanner_launch_data();
            Cron::updateTask(
                'scanner__launch',
                'spbc_scanner__launch',
                $scanner_launch_data['period'],
                $scanner_launch_data['start_time']
            );
        }

        $spbc->save('data');

        // Adding to log
        $duration_of_scanning = isset($spbc->data['scanner']['scan_start_timestamp'], $spbc->data['scanner']['scan_finish_timestamp'])
            ? '<b>' . sprintf(__('Scan duration %s seconds.', 'security-malware-firewall') . '</b>', $spbc->data['scanner']['scan_finish_timestamp'] - $spbc->data['scanner']['scan_start_timestamp'])
            : __('The duration of the scan is not known', 'security-malware-firewall');
        ScanningLogFacade::writeToLog($duration_of_scanning);

        $out = array(
            'end' => 1,
            'stage_data_for_logging' => array(
                'title' => $duration_of_scanning,
                'description' => ''
            )
        );
        if ( (bool)$error ) {
            $out['error'] = $error;
        }

        $this->end_of_scan = true;

        return $out;
    }
}
