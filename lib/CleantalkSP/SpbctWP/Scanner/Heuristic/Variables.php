<?php


namespace CleantalkSP\SpbctWP\Scanner\Heuristic;


class Variables
{
    public $variables     = array();
    public $variables_bad = array();
    public $arrays        = array();
    public $constants     = array();
    
    /**
     * @var Tokens
     */
    public $tokens;
    
    private $variables_types_to_concat = array(
        'T_CONSTANT_ENCAPSED_STRING',
        // 'T_ENCAPSED_AND_WHITESPACE',
        'T_LNUMBER',
        'T_DNUMBER',
    );
    
    private $sequences = array(
        
        'define_constant' => array(
            array( 'T_STRING', 'define' ),
            array( '__SERV', '(', ),
            array( 'T_CONSTANT_ENCAPSED_STRING' ),
            array( '__SERV', ',', ),
            array( 'T_CONSTANT_ENCAPSED_STRING' )
        ),
        
        'array_equation_array' => array(
            array( '__SERV', '=', ),
            array( 'T_ARRAY' ),
            array( '__SERV', '(', ),
        ),
        
        'array_equation_square_brackets' => array(
            array( '__SERV', '=', ),
            array( '__SERV', '[', ),
        )
    );
    
    public $variables_bad_default = array(
        '$_POST',
        '$_GET',
    );
    
    public function __construct( Tokens $tokens_handler )
    {
        $this->tokens = $tokens_handler;
    }
    
    /**
     * Replaces ${'string'} to $variable
     *
     * @param array[] $tokens
     * @param int     $key
     *
     * @return true returns true if changes were made in original $tokens array or false if isn't
     */
    public function convertVariableStrings(&$tokens, $key)
    {
        if( $tokens[$key] === '$' ){
            $next  = $tokens[$key + 1] ?: null;
            $next2 = $tokens[$key + 2] ?: null;
            
            if( $next === '{' && is_array($next2) && $next2[0] === 'T_CONSTANT_ENCAPSED_STRING' ){
                $tokens[$key] = array('T_VARIABLE', '$' . trim($next2[1], '\'"'), $next2[2]);
                unset($tokens[$key + 1], $tokens[$key + 2], $tokens[$key + 3]);
            }
        }
        
        return true;
    }
    
    /**
     * Array equation via 'Array' word
     * $arr = array();
     *
     * @param array[] $tokens
     * @param int     $key
     *
     * @return true returns false if current token( $tokens[ $key ] ) was unset or true if isn't
     */
    public function updateArray_equation(&$tokens, $key)
    {
        if( $this->tokens->checkSequenceFromPosition($key + 1, $this->sequences['array_equation_array']) ){
            $variable_end = $this->tokens->searchForward($key, ';') - 1;
            if( $variable_end ){
                $arr_lexemes = $this->tokens->getRange($key + 4, $variable_end - 1);
                foreach( $arr_lexemes as $arr_lexema ){
                    if( is_array($arr_lexema) && ($arr_lexema[0] === 'T_CONSTANT_ENCAPSED_STRING' || $arr_lexema[0] === 'T_LNUMBER') ){
                        $this->arrays[$tokens[$key][1]][] = array($arr_lexema[0], $arr_lexema[1], $arr_lexema[2]);
                    }
                }
            }
        }
        
        return true;
    }
    
    /**
     * Array equation via '[]' operator
     * $arr = [];
     *
     * @param array[] $tokens
     * @param int     $key
     *
     * @return true returns false if current token( $tokens[ $key ] ) was unset or true if isn't
     */
    public function updateArray_equationShort(&$tokens, $key)
    {
        if( $this->tokens->checkSequenceFromPosition($key + 1, $this->sequences['array_equation_square_brackets']) ){
            $variable_end = $this->tokens->searchForward($key, ';') - 1;
            if( $variable_end ){
                $arr_lexemes = $this->tokens->getRange($key + 3, $variable_end - 1);
                foreach( $arr_lexemes as $arr_lexema ){
                    if( is_array($arr_lexema) && ($arr_lexema[0] === 'T_CONSTANT_ENCAPSED_STRING' || $arr_lexema[0] === 'T_LNUMBER') ){
                        $this->arrays[$tokens[$key][1]][] = array(
                            'T_CONSTANT_ENCAPSED_STRING',
                            $arr_lexema[1],
                            $arr_lexema[2]
                        );
                    }
                }
            }
        }
        
        return true;
    }
    
    /**
     * Array. New element equation via
     * $arr[] = 'value';
     *
     * @param array[] $tokens
     * @param int     $key
     *
     * @return true returns false if current token( $tokens[ $key ] ) was unset or true if isn't
     */
    public function updateArray_newElement(&$tokens, $key)
    {
        $next1 = isset($tokens[$key + 1]) ? $tokens[$key + 1] : array(null, null, null);
        $next2 = isset($tokens[$key + 2]) ? $tokens[$key + 2] : array(null, null, null);
        $next3 = isset($tokens[$key + 3]) ? $tokens[$key + 3] : array(null, null, null);
        
        if( $next1[1] === '[' && $next2[1] === ']' && $next3[1] === '=' ){
            
            $var_temp = $this->tokens->getRange(
                $key + 4,
                $this->tokens->searchForward($key, ';') - 1
            );
            
            if( $var_temp ){
                $var_temp = $var_temp[0];
                if( $var_temp[0] === 'T_CONSTANT_ENCAPSED_STRING' || $var_temp[0] === 'T_LNUBMER' ){
                    $this->arrays[$tokens[$key][1]][] = array($var_temp[0], $var_temp[1], $var_temp[2]);
                }
            }
        }
        return true;
    }

    /**
     * Simple equation
     * $a = 'value';
     *
     * @param array[] $tokens
     * @param int     $key
     *
     * @return true returns false if current token( $tokens[ $key ] ) was unset or true if isn't
     */
    public function updateVariables_equation(&$tokens, $key)
    {
        // Simple equation
        // $a = 'value';
        if( $tokens[$key][0] === 'T_VARIABLE' ){
            
            $next = isset($tokens[$key + 1]) ? $tokens[$key + 1] : array(null, null, null);
            
            if( $next[1] === '=' ){
                $variable_end = $this->tokens->searchForward($key, ';') - 1;
                if($variable_end){
                    $var_temp = $this->tokens->getRange($key + 2, $variable_end);
                    $var_temp = count($var_temp) === 3 && $var_temp[0] === '"' &&  $var_temp[1][0] === 'T_ENCAPSED_AND_WHITESPACE' && $var_temp[2] === '"'
                        ? array( array( 'T_CONSTANT_ENCAPSED_STRING', '\'' . $var_temp[1][1] . '\'', $var_temp[1][2] ) )// Variable in a double quotes like $a = "$b";
                        : $var_temp; // // Variable in a single quotes like $a = 'value';
                
                    $this->variables[$tokens[$key][1]] = $var_temp;
                }
            }
        }
        return true;
    }
    
    /**
     * Equation with concatenation.
     * $a .= 'value';
     *
     * @param array[] $tokens
     * @param int     $key
     *
     * @return true returns false if current token( $tokens[ $key ] ) was unset or true if isn't
     */
    public function updateVariables_equationWithConcatenation(&$tokens, $key)
    {
        if( $tokens[$key][0] === 'T_VARIABLE' ){
            
            $next = isset($tokens[$key + 1]) ? $tokens[$key + 1] : array(null, null, null);
            
            if( $next[0] === 'T_CONCAT_EQUAL' ){
                
                $var_temp = $this->tokens->getRange(
                    $key + 2,
                    $this->tokens->searchForward($key, ';') - 1
                );
                
                if( $var_temp ){
                    
                    // Variable in a double quotes like $a .= "$b";
                    // We don't touch variables in a single quotes like $a .= 'value';
                    if(
                        count( $var_temp ) === 3 &&
                        $var_temp[0] === '"' &&
                        $var_temp[1][0] === 'T_ENCAPSED_AND_WHITESPACE' &&
                        $var_temp[2] === '"'
                    ){
                        $var_temp = array(
                            array(
                                'T_CONSTANT_ENCAPSED_STRING',
                                '\'' . $var_temp[1][1] . '\'',
                                $var_temp[1][2],
                            ),
                        );
                    }
    
                    $this->variables[$tokens[$key][1]] = isset( $this->variables[$tokens[$key][1]] )
                        ? array_merge($this->variables[$tokens[$key][1]], $var_temp)
                        : $var_temp;
                }
            }
        }
        
        return true;
    }
    
    /**
     * Search and remember constants definition
     * define('CONSTANT_NAME','CONSTANT_VALUE'
     *
     * @param array[] $tokens
     * @param int     $key
     *
     * @return true returns false if current token( $tokens[ $key ] ) was unset or true if isn't
     */
    public function updateConstants(&$tokens, $key)
    {
        // Constants
        if(
            isset( $tokens[ $key +4 ][0] ) &&
            $tokens[ $key +4 ][0] === 'T_CONSTANT_ENCAPSED_STRING' &&
            $this->tokens->checkSequenceFromPosition($key, $this->sequences['define_constant'] )
        ){
            $this->constants[ trim( $tokens[ $key + 2 ][1], '\'"' ) ] = trim( $tokens[ $key + 4 ][1], '\'"' );
        }
        
        return true;
    }
    
    /**
     * Concatenate variable in $this->variables
     *
     * @return void
     */
    public function concatenate(){
        
        foreach($this->variables as $var_name => $var){
            for($i = count($var)-1; $i > 0; $i--){
                $curr = isset($var[$i])   ? $var[$i]   : null;
                $next = isset($var[$i-1]) ? $var[$i-1] : null;
                if(
                    in_array( $curr[0], $this->variables_types_to_concat, true ) &&
                    in_array( $next[0], $this->variables_types_to_concat, true )
                ){
                    Controller::_concatenate($this->variables[$var_name], $i, true);
                }
            }
        }
    }
    
    /**
     * Replace variables with it's content
     *
     * @param $tokens
     *
     * @return void
     */
    public function replace( &$tokens )
    {
        $in_quotes = false;
        for(
            $key = 0,
            $current = null,
            $arr_size = count($tokens);
            
            $key < $arr_size;
            
            $key++,
            $current = isset($tokens[$key]) ? $tokens[$key] : null
        ){
            
            if( $current === null ){
                continue;
            }
            
            if( $current === '"' ){
                $in_quotes = ! $in_quotes;
            }
            
            // Replace variable
            if( is_array( $current ) && $current[0] === 'T_VARIABLE' ){
                
                $next1 = isset( $tokens[ $key + 1 ] ) ? $tokens[ $key + 1 ] : null;
                $next2 = isset( $tokens[ $key + 2 ] ) ? $tokens[ $key + 2 ] : null;
                
                // Arrays
                if( isset( $this->arrays[ $current[1] ] ) ){
                    
                    $next = $this->tokens->getRange($key + 1, $key + 4 );
                    
                    // Array element
                    if( isset( $next[0] ) && $next[0] === '[' && isset( $next[1][0] ) && $next[1][0] === 'T_LNUMBER' && in_array( $next[3], array( '.', '(', ';' ) ) ){
                        
                        if( isset( $this->arrays[ $current[1] ][ $next[1][1] ][1] ) ){
                            
                            if( $next[3] === '(' ){
                                $tokens[ $key ] = array( 'T_STRING',                   substr( $this->arrays[ $current[1] ][ $next[1][1] ][1], 1, - 1 ), $current[2] );
                            }elseif( $next[3] === '.' ){
                                $tokens[ $key ]= array( 'T_CONSTANT_ENCAPSED_STRING', '\'' . $this->arrays[ $current[1] ][ $next[1][1] ][1] . '\'',                 $current[2] );
                            }else{
                                $tokens[ $key ]= array( $this->arrays[ $current[1] ][ $next[1][1] ][0], '\'' . $this->arrays[ $current[1] ][ $next[1][1] ][1] . '\'',                 $current[2] );
                            }
                            
                            unset( $tokens[ $key + 1 ], $tokens[ $key + 2 ], $tokens[ $key + 3 ] );
                            
                        }
                    }
                    
                // Variables
                }elseif(
                    isset( $this->variables[ $current[1] ] ) &&
                    count( $this->variables[ $current[1] ] ) === 1 &&
                    in_array( $this->variables[ $current[1] ][0][0], $this->variables_types_to_concat, true )
                ){
                    
                    // Array or symbol from string replacement
                    if( ( $next1 === '[' || $next1 === '{' ) && is_array( $next2 ) && $next2[0] === 'T_LNUMBER' ){
                        
                        if( isset( $this->variables[ $current[1] ][0][1][ $next2[1] ], $this->variables[ $current[1] ][0][1][ $next2[1] + 1 ] ) ){
                            $tokens[ $key ][0] = 'T_CONSTANT_ENCAPSED_STRING';
                            $tokens[ $key ][1] = '\'' . $this->variables[ $current[1] ][0][1][ $next2[1] + 1 ] . '\'';
                            $tokens[ $key ][2] = $current[2];
                            unset( $tokens[ $key + 1 ], $tokens[ $key + 2 ], $tokens[ $key + 3 ] );
                        }
                        
                    // @todo Learn to replace $$var to $var_value
                    // }elseif( is_array( $next ) && $next === 'T_VARIABLE' ){
                        
                        
                    // Single variable replacement
                    }else{
                        
                        // Variables function
                        if( $next1 === '(' ){
                            $tokens[ $key ][0] = 'T_STRING';
                            $tokens[ $key ][1] = substr( $this->variables[ $current[1] ][0][1], 1, - 1 );
                            $tokens[ $key ][2] = $current[2];
                            
                            // Variables in double/single quotes
                        }elseif( ! $this->tokens->isTokenInGroup($next1[0], 'equation') ){
                            $tokens[ $key ][0] = ! $in_quotes ? 'T_CONSTANT_ENCAPSED_STRING' : 'T_ENCAPSED_AND_WHITESPACE';
                            $tokens[ $key ][1] = ! $in_quotes ? $this->variables[ $current[1] ][0][1] : substr( $this->variables[ $current[1] ][0][1], 1, - 1 );
                            $tokens[ $key ][2] = $current[2];
                        }
                    }
                }
                
            // Constant replacement
            }elseif( isset( $current[0] ) && $current[0] === 'T_STRING' && isset( $this->constants[ $current[1] ] )){
                $tokens[ $key ] = array( 'T_CONSTANT_ENCAPSED_STRING', '\'' . $this->constants[ $current[1] ] . '\'', $current[2] );
            }
        }
    }
    
    /**
     * Add variables with user input to BAD list
     */
    public function detectBad()
    {
        do{
            $bad_vars_count = count($this->variables_bad);
            
            foreach( $this->variables as $var_name => &$variable ){
                foreach( $variable as &$var_part ){
                    if(
                        $var_part[0] === 'T_VARIABLE' &&
                        (in_array($var_part[1], $this->variables_bad_default, true) || isset($this->variables_bad[$var_part[1]]))
                    ){
                        $this->variables_bad[$var_name] = $variable;
                        continue(2);
                    }
                }
                unset($var_part);
            }
            unset($variable);
        }while( $bad_vars_count !== count($this->variables_bad) );
    }
    
    /**
     * Check the set of tokens for bad variables
     *
     * @param $tokens
     *
     * @return bool
     */
    public function isSetOfTokensHasBadVariables($tokens)
    {
        return in_array('T_VARIABLE', array_column($tokens, 0), true) &&
               (
                   array_intersect(array_column($tokens, 1), $this->variables_bad_default) ||
                   array_intersect(array_column($tokens, 1), array_keys($this->variables_bad))
               );
    }
    
    /**
     * Check if the given token in arrays
     *
     * @param $token
     *
     * @return bool
     */
    public function isTokenInArrays($token)
    {
        return $this->tokens->isTypeOf('T_VARIABLE', $token) && isset($this->arrays[$token[1]]);
    }
    
    /**
     * Check if the given token in arrays
     *
     * @param $token
     *
     * @return bool
     */
    public function isTokenInVariables($token)
    {
        return $this->tokens->isTypeOf('T_VARIABLE', $token) && isset($this->variables[$token[1]]);
    }
    
    /**
     * Check if the given token in arrays
     *
     * @param $token
     *
     * @return bool
     */
    public function isTokenInConstants($token)
    {
        return $this->tokens->isTypeOf('T_STRING', $token) && isset($this->constants[$token[1]]);
    }
}