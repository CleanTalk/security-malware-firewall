<?php

namespace CleantalkSP\SpbctWp\Scanner\Heuristic;

/**
 * Class Heuristic
 *
 * @package Security Plugin by CleanTalk
 * @subpackage Scanner
 * @Version 2.3
 * @author Cleantalk team (welcome@cleantalk.org)
 * @copyright (C) 2014 CleanTalk team (http://cleantalk.org)
 * @license GNU/GPL: http://www.gnu.org/copyleft/gpl.html
 * @see https://github.com/CleanTalk/security-malware-firewall
 */
class Controller
{
	// Constants
	const FILE_MAX_SIZE = 524288; // 512 KB
    
	// Current file attributes
	/**
	 * @var bool Defines if the passed code is plain text
	 */
	public $is_text       = false;
	public $is_evaluation = false;
	
	public $extension      = null; // File extension
	public $path           = null; // File path
	public $curr_dir       = null; // File path
	public $file_size      = 0;    // File size
 
	public $tokens    = array(); // Array with file lexems
	
	public $file_content   = '';   // Original
	public $file_work      = '';   // Work copy
	public $file_stamp     = '';
	
	public $includes       = array();
	public $sql_requests   = array();
	public $evaluations    = array();
    
    public $error               = array();
	private $properties_to_pass = array(
		'is_evaluation',
		'variables',
		'arrays',
		'constants',
		'variables_bad'
	);
	
	public $verdict = array(); // Scan results
	public $looks_safe = false;
	
	private $output_constructs = array(
		'T_ECHO',
		'T_PRINT',
	);
	
	private $evaluation_constructs = array(
		'create_function',
		'eval',
		'assert',
	);
	
	private $bad_constructs = array(
		'CRITICAL' => array(
			'eval',
			'assert',
			'create_function',
		),
		'DANGER' => array(
			'system',
			'passthru',
			'proc_open',
			'exec',
		),
		'SUSPICIOUS' => array(
			'base64_encode',
			'base64_decode',
			'str_rot13',
			'syslog',
		),
	);
	
	private $whitespace_lexem = array(
		'T_WHITESPACE',
		' ',
		null,
	);
	
	/** Modules */
    
    /**
     * @var Tokens
     */
    private $token_handler;
    /**
     * @var Simplifier
     */
    private $simplifier;
    /**
     * @var Strings
     */
    private $strings;
    /**
     * @var Variables
     */
    private $variables;
    
    /**
	 * Heuristic constructor.
	 * Getting common info about file|text and it's content
	 *
	 * @param array $input
	 * @param self  $self
	 */
	public function __construct( $input, $self = null ){
		
		// Accept
		if( $self && $self instanceof self ){
			
			foreach( $input as $property_name => $property_value ){
				if( in_array( $property_name, $this->properties_to_pass ) )
					$this->$property_name = $property_value;
			}
			
		}
		
		// Accept file as a string
		if( isset( $input['content'] ) ){
			
			$this->is_text   = true;
			
			if( $this->checkFileSize(strlen($input['content'] ) ) ){
				$this->file_size    = strlen( $input['content'] );
				$this->file_work    = $input['content'];
				$this->file_content = $this->file_work;
			}
			
			// Accept file as a path
		}elseif( isset( $input['path'] ) ){
			
			$this->path      = $input['path'];
			$this->curr_dir  = dirname( $this->path );
			$this->extension = pathinfo( $this->path, PATHINFO_EXTENSION );
			
			if( $this->checkFileAccessibility() && $this->checkFileSize(filesize($this->path ) ) )
			{
				$this->file_size    = (int) filesize( $this->path );
				$this->file_work    = file_get_contents( $this->path );
				$this->file_content = $this->file_work;
			}
			
			// Bad params provided
		}else{
            $this->error = array('error' => 'BAD_PARAMS');
            
            return;
        }
		
		$this->token_handler = new Tokens();
        $this->simplifier    = new Simplifier($this->token_handler);
        $this->strings       = new Strings($this->token_handler);
        $this->variables     = new Variables($this->token_handler);
        
		$this->token_handler->getTokensFromText($this->file_content );
		$this->tokens = &$this->token_handler->tokens;
  
	}
	
	private function checkFileAccessibility(){
		
		if( ! file_exists( $this->path ) ){
			$this->error = array( 'error' => 'FILE_NOT_EXISTS' );
			return false;
		}
		
		if( ! is_readable( $this->path ) ){
			$this->error = array( 'error' => 'FILE_NOT_READABLE' );
			return false;
		}
  
		if( ! is_file( $this->path ) || is_dir( $this->path ) || is_link( $this->path ) ){
			$this->error = array( 'error' => 'IS_NOT_A_FILE' );
			return false;
		}
		
		return true;
	}
	
	private function checkFileSize( $file_size ){
		
		if( ! (int) $file_size ){
			$this->error = array( 'error' => 'FILE_SIZE_ZERO' );
			return false;
		}
		
		if( (int) $file_size > self::FILE_MAX_SIZE ){
			$this->error = array( 'error' => 'FILE_SIZE_TO_LARGE' );
			return false;
		}
		
		return true;
	}
	
	/**
	 * Process file.
	 * Do all the work
	 *
	 * All the results in the $this->verdict
	 *
	 * @return void
	 */
	public function processContent(){
        
        do{
            
            $stamp = $this->createStamp();
            
            foreach( $this->tokens as $key => &$current_token ){
                
                $this->token_handler->setCurrent($current_token );
    
                if( ! $this->simplifier->extractNonCodeTokens($this->tokens, $key) ) continue;
                if( ! $this->simplifier->stripWhitespaces($this->tokens, $key) )     continue;
                
                $this->strings->convertToSimple( $this->tokens, $key );
                $this->strings->convertChrFunctionToString( $this->tokens, $key );
                $this->strings->convertHexSymbolsToString( $this->tokens, $key );
                
                $this->strings->concatenateSimpleStrings( $this->tokens, $key );
                $this->strings->concatenateComplexStrings( $this->tokens, $key );
    
                $this->variables->convertVariableStrings($this->tokens, $key);
                
                $this->variables->updateVariables_equation($this->tokens, $key);
                //error_log( var_export( $this->variables->variables, true ) );
                $this->variables->updateVariables_equationWithConcatenation($this->tokens, $key);
                
                $this->variables->updateArray_equation($this->tokens, $key);
                $this->variables->updateArray_equationShort($this->tokens, $key);
                $this->variables->updateArray_newElement($this->tokens, $key);
                
                $this->variables->updateConstants($this->tokens, $key);
                
            } unset( $current_token );
            
            \CleantalkSP\Common\Helper::array_reindex( $this->tokens );
            
            $this->variables->concatenate(); // Concatenates variable content if it's possible
            $this->variables->replace( $this->tokens ); // Replaces variables with its content
            
            $this->decodeData();
            
        }while( $stamp !== $this->createStamp() );
		
		// Mark evaluation as safe if it matches conditions
		if( $this->is_evaluation &&
		    (
			    // Only output
                (isset( $this->tokens[1][0] ) && in_array($this->tokens[1][0], $this->output_constructs, true ) ) ||
                // Empty
                (count( $this->tokens ) === 1 )
		    )
		){
			$this->looks_safe = true;
			
			return;
		}
		
		// Getting construction
		
		// Detecting bad variables
		$this->variables->detectBad();
		
		// Getting all include constructions and detecting bad
//        $this->includes_standardize();
		$this->includes_getAll();
		
		// Getting all MySQL requests and detecting bad
		$this->sql_requests_getAll();
		
		$this->evaluation_getAll();
		
		// Making verdict
		$this->make_verdict();
		
		if( $this->evaluations ){
			foreach( $this->evaluations as $evaluation_string => $evaluation ){
				$sub = new self(array('content' => $evaluation, 'is_evaluation' => true, ), $this );
				$sub->processContent();
				
				// Set eval string like in a parent
				foreach( $sub->verdict as &$vulnerabilities ){
					$vulnerabilities = array( $evaluation_string => current( $vulnerabilities ) );
				}unset( $vulnerabilities );
				
				// Merge verdicts
				$this->verdict = array_merge_recursive( $this->verdict, $sub->verdict );
				if( $sub->looks_safe ){
					unset( $this->verdict['CRITICAL'][ $evaluation_string ] );
				}
			}
		}
	}
    
    private function createStamp(){
	    return md5($this->token_handler->glueTokens());
    }
    
	// Brings all such constructs to include'path';
	public function includes_standardize()
	{
		for(
			$key = 0,
			$current = null,
			$arr_size = count($this->tokens);
			
			$key < $arr_size;
			
			$key++,
			$current = isset($this->tokens[$key]) ? $this->tokens[$key] : null
		){
			if( $current &&
			    ( strpos($current[0], 'INCLUDE') !== false || strpos($current[0], 'REQUIRE') !== false )
			){
				if( $this->tokens[$key + 1] === '('){
					$next_bracket = $this->token_handler->searchForward($key, ')');
					if($next_bracket !== false){
						unset( $this->tokens[$key + 1 ] );
					}
					unset($this->tokens[$next_bracket]);
				}
				$this->tokens = array_values($this->tokens);
			}
		}
	}
	
	/**
	 * Gets all of the include and require constructs. Checks for file extension and checks the path.
	 *
	 * @return void
	 */
	public function includes_getAll()
	{
		for(
			$key = 0,
			$current = null,
			$arr_size = count($this->tokens);
			
			$key < $arr_size;
			
			$key++,
			$current = isset($this->tokens[$key]) ? $this->tokens[$key] : null,
			$prev_file_exists__key = null,
			$prev_file_exists      = null
		
		){
			if (
				! is_null( $current ) &&
				in_array(
					$current[0],
					array( 'T_INCLUDE', 'T_INCLUDE_ONCE', 'T_REQUIRE', 'T_REQUIRE_ONCE' )
				)
			){
				
				// Get previous "file_exists" function
				$prev_file_exists__start = $this->token_handler->searchBackward($key, 'file_exists' );
				$prev_file_exists__end = $prev_file_exists__start
					? $this->token_handler->searchForward($prev_file_exists__start, ')' )
					: null;
				$prev_file_exists = $prev_file_exists__start && $prev_file_exists__end
					? $this->token_handler->getRange($prev_file_exists__start, $prev_file_exists__end)
					: null;
				
				$include_end = $this->token_handler->searchForward($key, ';') - 1;
				if($include_end){
					$include = $this->token_handler->getRange($key + 1, $include_end);
					if( $prev_file_exists ){
						$include['file_exists'] = $prev_file_exists;
					}
					$this->includes_processsAndSave($include, $key);
				}
				
			}
		}
	}
	
	public function includes_processsAndSave($include, $key)
	{
		// Check flags
		$unknown  = true;
		$good     = true;
		$status   = true;
		$not_url  = null;
		$dir      = $this->curr_dir;
		$name     = null;
		$path     = null;
		$exists   = null;
		$ext      = null;
		$ext_good = null;
		
		// Checking for bad variables in include
		foreach($include as $value){
			if($value[0] === 'T_VARIABLE' && (in_array($value[1], $this->variables->variables_bad_default) || isset($this->variables_bad[$value[1]]))){
				$good = false;
				break;
			}
		} unset($value);
		
		// Checking for @ before include
		$error_free = $this->tokens[$key - 1] === '@' ? false : true;
		
		// Include is a single string
		if(
			(count($include) == 1 && $include[0][0] === 'T_CONSTANT_ENCAPSED_STRING') or
			(count($include) == 3 && $include[0] === '(' && $include[1][0] === 'T_CONSTANT_ENCAPSED_STRING')
		){
			
			// Cutting quotes
			$path = count($include) == 3
				? substr($include[1][1], 1, -1)
				: substr($include[0][1], 1, -1);
			$not_url  = !filter_var($path, FILTER_VALIDATE_URL) ? true : false; // Checks if it is URL
			$is_absolute = preg_match( '@^([A-Z]:[\\\\\/]|[\\\\/])@', $path, $matches); // Reconizing if path is absolute.
			$path     = ! $is_absolute && $not_url
				? $this->curr_dir . DIRECTORY_SEPARATOR . $path
				: $path;  // Make path absolute
			$name     = basename( $path );
			$exists   =
				$this->is_text &&
				! (
					isset( $include['file_exists'] ) &&
					$include['file_exists'][2][0] === 'T_CONSTANT_ENCAPSED_STRING' &&
					$include['file_exists'][2][0] === $path
				)
					? null
					: (realpath($path) ? true : false); // Checks for existence. null if checking text (not file).
			preg_match('/.*\.(\S*)$/', $path, $matches2);          // Reconizing extension.
			$ext      = isset($matches2[1]) ? $matches2[1] : '';
			$ext_good = in_array($ext, array('php', 'inc')) || is_dir($path) ? true : false;             // Good extension?
			
			$unknown  = false;
		}
		
		// Gather result in one flag
		$status = $good
			? (!$unknown
				? (!$not_url || !$ext_good
					? false
					: true)
				: null)
			: false;
		
		//$status = $good ? ($error_free ? ($unknown ? null : (!$not_url || !$exists || !$ext_good ? false : true)) : false) : false; // prev versison
		
		array_unshift($include, $this->tokens[$key]);
		
		$this->includes[] = array(
			'include'    => $include,
			'good'       => $good,
			'status'     => $status,
			'not_url'    => $not_url,
			'dir'        => $dir,
			'name'       => $name,
			'path'       => $path,
			'exists'     => $exists,
			'error_free' => $error_free,
			'ext'        => $ext,
			'ext_good'   => $ext_good,
			'string'     => $this->tokens[$key][2],
		);
	}
	
	/**
	 * Gets all evaluation constructions in $this->evaluations to scan them later
	 *
	 * @return void
	 */
	public function evaluation_getAll(){
		for(
			$key = 0,
			$current = null,
			$arr_size = count($this->tokens);
			
			$key < $arr_size;
			
			$key++,
			$current = isset($this->tokens[$key]) ? $this->tokens[$key] : null,
			$prev_file_exists__key = null,
			$prev_file_exists      = null
		){
			if( ! is_null( $current ) && isset( $current[1] ) && in_array( $current[1], $this->evaluation_constructs ) ){
				
				// Put found code (not tokens) in the $this->evaluations[ string ]
				$lexems = $this->token_handler->getRange(
					$key + 2,
					$this->token_handler->searchForward( $key, ';' ) - 2
				);
				$this->evaluations[ $current[2] ] = '<?php ' . trim( $this->token_handler->glueTokens( $lexems ), '\'"' );
			}
		}
	}
	
	public function sql_requests_getAll(){
		for(
			$key = 0, $current = null, $arr_size = count($this->tokens);
			$key < $arr_size;
			$key++
		){
			
			$current = $this->tokens[$key] ?: null;
			$sql_start = null;
			$sql_end = null;
			
			if( $current === null )
				continue;
			
			// WPDB
			if(
				$current[0] === 'T_VARIABLE' &&
				isset( $this->tokens[$key + 3 ] ) &&
                $this->tokens[$key + 1][0] === 'T_OBJECT_OPERATOR' &&
                $this->tokens[$key + 2][0] === 'T_STRING' &&
                in_array($this->tokens[$key + 2][1], array( 'query', 'get_results' ) ) &&
                $this->tokens[$key + 3][0] === '('
			){
				$sql_start = $key + 4;
				$sql_end = $this->token_handler->searchForward($key, ';') - 1;
				
				// Mysqli
			}elseif(
				$current[0] === 'T_STRING' &&
				isset( $this->tokens[$key + 2 ] ) &&
                in_array( $current[1], array( 'MYSQLI', 'mysqli' ) ) &&
                $this->tokens[$key + 2 ][0] === 'T_STRING' &&
                in_array($this->tokens[$key + 2 ][1], array( 'query', 'send_query', 'multi_query' ) )
			){
				$sql_start = $key + 4;
				$sql_end   = $this->token_handler->searchForward( $key, ';' ) - 1;
				
				// PDO
			}elseif(
				$current[0] === 'T_STRING' &&
				isset( $this->tokens[$key + 2 ] ) &&
                in_array( $current[1], array( 'PDO', 'pdo' ) ) &&
                $this->tokens[$key + 2 ][0] === 'T_STRING' &&
                in_array($this->tokens[$key + 2 ][1], array( 'query', 'exec' ) )
			){
				$sql_start = $key + 4;
				$sql_end   = $this->token_handler->searchForward( $key, ';' ) - 1;
				
				// Mysql
			}elseif(
				$current[0] === 'T_STRING' &&
				in_array( $current[1], array( 'mysql_query', 'mysqli_query', 'mysqli_send_query', 'mysqli_multi_query' ) )
			){
				$sql_start = $key + 2;
				$sql_end   = $this->token_handler->searchForward( $key, ';' ) - 1;
			}
			
			
			if($sql_start && $sql_end){
				$sql = $this->token_handler->getRange($sql_start, $sql_end);
				$this->sql_requests_processAndSave($sql, $key);
			}
		}
	}
	
	public function sql_requests_processAndSave($sql, $key ){
		
		$good = true; // SQL request is good by default
		
		// Checking for bad variables in sql
		foreach($sql as $value){
			if( $value[0] === 'T_VARIABLE' && ( in_array( $value[1], $this->variables->variables_bad_default, true ) || isset( $this->variables_bad[ $value[1] ] ) ) ){
				$good = false;
				break;
			}
		}
		
		$status = ! empty( $good );
		
		$this->sql_requests[] = array(
			'sql'    => $sql,
			'status' => $status,
			'good'   => $good,
			'string' => $this->tokens[$key][2],
		);
		
	}
	
	public function make_verdict()
	{
		// Detecting bad functions
		foreach($this->tokens as $key => $lexem){
			if(is_array($lexem)){
				foreach( $this->bad_constructs as $severity => $set_of_functions){
					foreach($set_of_functions as $bad_function){
						if(
							$lexem[1] === $bad_function &&
							! (
								isset(
									$this->tokens[$key - 1 ],
									$this->tokens[$key - 1][0]
								) &&
                                $this->tokens[$key - 1][0] === 'T_OBJECT_OPERATOR'
							)
						){
							$this->verdict[$severity][$lexem[2]][] = $bad_function;
						}
					} unset($bad_function);
				} unset($severity, $set_of_functions);
			}
		}
		
		// Adding bad includes to $verdict['SEVERITY']['string_num'] = 'whole string with include'
		foreach($this->includes as $include){
			if($include['status'] === false){
				if($include['not_url'] === false or $include['ext_good'] === false)
					$this->verdict['CRITICAL'][$include['string']][] = substr($this->token_handler->glueTokens($include['include']), 0, 255);
				elseif($include['good'] === false)
					$this->verdict['SUSPICIOUS'][$include['string']][] = substr($this->token_handler->glueTokens($include['include']), 0, 255);
			}
		}
		
		// Adding bad sql to $verdict['SEVERITY']['string_num'] = 'whole string with sql'
		foreach($this->sql_requests as $sql){
			if($sql['status'] === false){
				$this->verdict['SUSPICIOUS'][$sql['string']][] = substr($this->token_handler->glueTokens($sql['sql']), 0, 255);
			}
		}
	}
	
	private function decodeData(){
		for(
			$key = 0,
			$current = null,
			$arr_size = count($this->tokens);
			
			$key < $arr_size;
			
			$key++,
			$current = isset($this->tokens[$key]) ? $this->tokens[$key] : null
		){
			
			// Decode for base64
			if( isset( $current[0] ) && $current[0] === 'T_STRING' ){
				
				$next = $this->token_handler->getRange($key + 1, $key + 2 );
				
				if( isset( $next[1] ) && $next[1][0] === 'T_CONSTANT_ENCAPSED_STRING' ){
					
					switch( $current[1] ){
						case 'base64_decode':
							$data = base64_decode( $next[1][1] );
							break;
						case 'urldecode':
							$data = urldecode( $next[1][1] );
							break;
						case 'rawurldecode':
							$data = rawurldecode( $next[1][1] );
							break;
						case 'gzinflate':
							$data = gzinflate( $next[1][1] );
							break;
						case 'str_rot13':
							$data = str_rot13( $next[1][1] );
							break;
						default:
							$data = false;
						
					}
					
					// Replacing function and data with it's result
					// decode_func('ENCODED_DATA') -> 'DECODED_DATA'
					if( $data ){
						$this->tokens[ $key ] = array( 'T_CONSTANT_ENCAPSED_STRING', '\'' . $data . '\'', $current[2] );
						// @todo Check for second parameter for gzinflate and base64_decode functions
						unset( $this->tokens[$key + 1 ], $this->tokens[$key + 2 ], $this->tokens[$key + 3 ] );
					}
					
					if( $data ){
						
						// Decompress from GZ gzuncompress
                        $prev = $this->token_handler->getRange($key - 2, $key - 1 );
						if( isset( $prev[0] ) && $prev[0][0] === 'T_STRING' && $prev[0][1] === 'gzuncompress' ){
							$data = gzuncompress( $data );
							if( $data ){
								
								unset( $this->tokens[$key - 1  ], $this->tokens[$key - 2 ], $this->tokens[$key + 4 ] );
								$this->tokens[ $key ] = array( 'T_CONSTANT_ENCAPSED_STRING', '\'' . $data . '\'', $current[2] );
								$data                 = token_get_all( '<?php ' . $data );
								
								if( $data ){
									unset( $data[0] );
									$this->tokens = array_merge($this->tokens, $data );
								}
								
							}
						}
					}
				}
			}
		}
	}
	
	/**
	 * Concatenates anything
	 *
	 * @param $lexems
	 * @param $curr_index
	 * @param bool $backwards
	 * @param string $type
	 */
	public static function _concatenate(&$lexems, $curr_index, $backwards = false, $type = 'T_ENCAPSED_AND_WHITESPACE'){
		$next_index = $curr_index + ($backwards ? (-1) : 1);
		$curr_val = $lexems[$curr_index][0] === 'T_CONSTANT_ENCAPSED_STRING' ? substr($lexems[$curr_index][1], 1, -1) : $lexems[$curr_index][1];
		$next_val = $lexems[$next_index][0] === 'T_CONSTANT_ENCAPSED_STRING' ? substr($lexems[$next_index][1], 1, -1) : $lexems[$next_index][1];
		$lexems[$next_index] = array(
			$lexems[$curr_index][0],
			'"' . ($backwards ? $next_val . $curr_val : $curr_val . $next_val) . '"',
			$lexems[$curr_index][2],
		);
		unset($lexems[$curr_index]);
	}
}
