<?php

namespace CleantalkSP\SpbctWP\Scanner\Heuristic;

class FunctionsDecryptorService
{
    private $tokens;
    private $suspiciousFunctions = array(
        'base64_decode',
        'str_rot13'
    );
    private $results = array();

    public function __construct(Tokens $tokens)
    {
        $this->tokens = $tokens;
        $this
            ->searchSuspiciousFunctions()
            ->searchFunctionArgs();
    }

    public function searchSuspiciousFunctions()
    {
        foreach ( $this->tokens as $index => $token ) {
            if (
                $token &&
                $token->type === 'T_STRING' &&
                in_array($token->value, $this->suspiciousFunctions)
            ) {
                $this->results[$index] = array(
                    'f_name' => $token->value
                );
            }
        }

        return $this;
    }

    public function searchFunctionArgs()
    {
        foreach ($this->results as $index => $item) {
            if (!$this->nextTokenValueIs('(', $index)) {
                continue;
            }
//            d($this->nextTokenValueIs('(', $index));
//            d($this->tokens[$index+1]);
//            if ($this->tokens[$index+1]->value !== '(') {
//                continue;
//            }
//            d($this->tokens[$index]);
//            $current_token_index = $this->tokens[$index+1];
//            dd($current_token_index);
//            if ($this->tokens[$index]->next()) {
//
//            }
        }
        //dd(base64_decode /*retrtrt*/ ('123'));
    }

    public function nextTokenValueIs($string, $currentTokenIndex, $limit = 10)
    {
        for ($i = 1; $i <= $limit; $i++) {
            if ($this->tokens[$currentTokenIndex + $i] && $this->tokens[$currentTokenIndex + $i]->value !== $string) {
                return false;
            }
            if ($this->tokens[$currentTokenIndex + $i] && $this->tokens[$currentTokenIndex + $i]->value === $string) {
                return true;
            }
        }

        return false;
    }
}