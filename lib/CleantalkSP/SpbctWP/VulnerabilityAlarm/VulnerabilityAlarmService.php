<?php

namespace CleantalkSP\SpbctWP\VulnerabilityAlarm;

use CleantalkSP\SpbctWP\VulnerabilityAlarm\Dto\ApiResults;
use CleantalkSP\SpbctWP\VulnerabilityAlarm\Dto\PluginReport;
use CleantalkSP\SpbctWP\VulnerabilityAlarm\Dto\ThemeReport;
use CleantalkSP\SpbctWP\VulnerabilityAlarm\Exceptions\VulnerabilityAlarmServiceException;

class VulnerabilityAlarmService
{
    /**
     * @throws VulnerabilityAlarmServiceException
     */
    public static function updateVulnerabilitiesLibrary()
    {
        $modules = self::getModules();
        $report = self::getReport($modules);
        self::writeReport($report);
        self::setSummaryLogPluginsAndThemes($modules);
    }

    /**
     * @param array $modules
     */
    public static function setSummaryLogPluginsAndThemes($modules)
    {
        global $spbc;

        if ($modules['themes'] && is_array($modules['themes'])) {
            $spbc->scan_themes_info['total_site_themes_count'] = count($modules['themes']);

            $theme_is_vulnerable = self::getVulnerabilityThemes($modules['themes']);
            $spbc->scan_themes_info['themes_info_requested'] = count($modules['themes']);

            if ($theme_is_vulnerable && is_array($theme_is_vulnerable)) {
                $spbc->scan_themes_info['themes_found_with_known_vulnerabilities'] = count($theme_is_vulnerable);
            }
            $spbc->save('scan_themes_info');
        }

        if ($modules['plugins'] && is_array($modules['plugins'])) {
            $spbc->scan_plugins_info['total_site_plugins_count'] = count($modules['plugins']);

            $number_of_vulnerable_plugins = 0;
            $plugins_info_requested = 0;

            foreach ($modules['plugins'] as $plugin) {
                $plugin_slug = $plugin[0];
                $plugin_version = $plugin[1];
                $plugin_is_vulnerable = VulnerabilityAlarm::checkPluginVulnerability($plugin_slug, $plugin_version);
                $plugins_info_requested++;
                if ($plugin_is_vulnerable) {
                    $number_of_vulnerable_plugins++;
                }
            }

            $spbc->scan_plugins_info['plugins_info_requested'] = $plugins_info_requested;
            $spbc->scan_plugins_info['plugins_found_with_known_vulnerabilities'] = $number_of_vulnerable_plugins;

            $spbc->save('scan_plugins_info');
        }
    }

    /**
     * @param string $plugin_slug
     * @param string $plugin_version
     *
     * @return PluginReport|false
     */
    public static function checkPlugin($plugin_slug, $plugin_version, $safety_check = false)
    {
        if ( empty($plugin_version) ) {
            return false;
        }

        foreach ( VulnerabilityAlarm::$plugins as $plugin ) {
            if ( $plugin->slug === $plugin_slug ) {
                if ( $safety_check ) {
                    if ( static::isPluginVersionIsSafe($plugin, $plugin_version) ) {
                        return $plugin;
                    }
                } elseif ( static::isPluginVersionIsVulnerable($plugin, $plugin_version) ) {
                    return $plugin;
                }
            }
        }
        return false;
    }

    /**
     * @param PluginReport $plugin
     * @param string $plugin_version Installed plugin version to check
     *
     * @return bool
     */
    public static function isPluginVersionIsVulnerable($plugin, $plugin_version)
    {
        // If the plugin record is not vulnerability record - skip
        if ( $plugin->app_status !== 'vulnerable' ) {
            return false;
        }

        // If min rs_app_version_max not provided
        if ( empty($plugin->rs_app_version_max) ) {
            return true;
        }

        // if no rs_app_version_min provided, makes module
        // think that all the version below rs_app_version_max is vulnerable
        if ( empty($plugin->rs_app_version_min) ) {
            $plugin->rs_app_version_min = '0.0';
        }

        // If min rs_app_version_max provided - check this
        if (
            version_compare($plugin->rs_app_version_min, $plugin_version, '<=') &&
            version_compare($plugin->rs_app_version_max, $plugin_version, '>')
        ) {
            return true;
        }

        return false;
    }

    private static function isPluginVersionIsSafe($plugin, $plugin_version)
    {
        // If the plugin record is not safe record - skip
        if ( $plugin->app_status !== 'safe' ) {
            return false;
        }

        // If min rs_app_version_max provided - check this
        if ( version_compare($plugin->rs_app_version_min, $plugin_version, '=') ) {
            return true;
        }

        return false;
    }

    /**
     * @param array $theme_slug
     *
     * @return array
     */
    public static function getVulnerabilityThemes($theme_slug)
    {
        try {
            $report = self::getReport(['themes' => $theme_slug]);
        } catch (\Exception $_exception) {
            return $theme_slug;
        }

        $list_vlnerability_themes = array();
        if (count($report->themes) > 0) {
            foreach ($report->themes as $theme_name) {
                if ($theme_name->app_status == 'vulnerable') {
                    array_push($list_vlnerability_themes, $theme_name->slug);
                }
            }
            return $list_vlnerability_themes;
        }
        return [];
    }

    /**
     * @param array $theme_slug
     *
     * @return array
     */
    public static function getSafeThemes($theme_slug)
    {
        try {
            $report = self::getReport(['themes' => $theme_slug]);
        } catch (\Exception $_exception) {
            return $theme_slug;
        }

        $list_safe_themes = array();
        if (count($report->themes) > 0) {
            foreach ($report->themes as $theme_name) {
                if ($theme_name->app_status == 'safe') {
                    array_push($list_vlnerability_themes, $theme_name->slug);
                }
            }
            return $list_safe_themes;
        }
        return [];
    }

    /**
     * @param array $modules
     * @param array $list
     *
     * @psalm-suppress UnusedParam
     * @psalm-suppress UnusedMethod
     * @todo replace the suppressing above
     */
    private static function compare($modules, $list)
    {
    }

    /**
     * Gathering info about installed modules
     *
     * @return array
     */
    private static function getModules()
    {
        $modules = [
            'themes' => [],
            'plugins' => []
        ];

        require_once(ABSPATH . 'wp-admin/includes/plugin.php');
        require_once(ABSPATH . 'wp-admin/includes/theme.php');

        $plugins = get_plugins();
        $themes = wp_get_themes();

        foreach ($themes as $theme) {
            $modules['themes'][] = [
                $theme->get_stylesheet(),
                $theme->get('Version')
            ];
        }

        foreach ($plugins as $plugin) {
            $modules['plugins'][] = [
                sanitize_title($plugin['Name']),
                $plugin['Version']
            ];
        }

        return $modules;
    }

    /**
     * Get info about vulnerabilities from cloud
     *
     * @param $modules array
     *
     * @return ApiResults
     *
     * @throws VulnerabilityAlarmServiceException
     */
    public static function getReport($modules)
    {
        if ( ! is_array($modules) ) {
            throw new VulnerabilityAlarmServiceException('Modules not provided.');
        }

        $modules_names = [];
        foreach ( $modules as $module_types ) {
            if ( is_array($module_types) ) {
                foreach ( $module_types as $module ) {
                    if ( isset($module[0]) ) {
                        $modules_names[] = $module[0];
                    }
                }
            }
        }

        if ( empty($modules_names) ) {
            throw new VulnerabilityAlarmServiceException('Modules names not found.');
        }

        $api_res = ResearchApi::method__research_list(json_encode($modules_names));

        if ( isset($api_res['error']) ) {
            throw new VulnerabilityAlarmServiceException('API error: ' . $api_res['error']);
        }

        // Convert API request to the usable format
        $results = static::mapApiResults($api_res);

        return $results;
    }

    /**
     * Save vulnerability info
     */
    private static function writeReport($report)
    {
        update_option(VulnerabilityAlarm::VULNERABILITY_LIST, $report);
    }

    /**
     * @param $api_res
     *
     * @return ApiResults
     */
    private static function mapApiResults($api_res)
    {
        $results = new ApiResults();
        foreach ( $api_res as $res ) {
            // Skip apps without versions
            if ( is_null($res['rs_app_version_min']) && is_null($res['rs_app_version_max']) ) {
                continue;
            }
            if ( isset($res['app_type'], $res['app_name'], $res['app_status']) ) {
                switch ( $res['app_type'] ) {
                    case 'plugin':
                    default:
                        $report = new PluginReport();
                        break;
                    case 'theme':
                        $report = new ThemeReport();
                        break;
                }

                $report->slug = $res['slug'];
                $report->app_status = $res['app_status'];
                if ( isset($res['id']) ) {
                    $report->id = $res['id'];
                }
                if ( isset($res['CVE']) ) {
                    $report->CVE = $res['CVE'];
                }
                if ( isset($res['date']) ) {
                    $report->date = $res['date'];
                }
                if ( isset($res['rs_app_version_min']) ) {
                    $report->rs_app_version_min = $res['rs_app_version_min'];
                }
                if ( isset($res['rs_app_version_max']) ) {
                    $report->rs_app_version_max = $res['rs_app_version_max'];
                }

                // generates `$results->plugins` or `$results->themes`
                $res_type = $res['app_type'] . 's';
                $results->{$res_type}[] = $report;
            }
        }
        return $results;
    }
}
