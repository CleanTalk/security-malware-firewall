<?php

namespace CleantalkSP\SpbctWP\VulnerabilityAlarm;

use CleantalkSP\SpbctWP\VulnerabilityAlarm\Dto\ApiResults;
use CleantalkSP\SpbctWP\VulnerabilityAlarm\Dto\PluginReport;
use CleantalkSP\SpbctWP\VulnerabilityAlarm\Dto\ThemeReport;
use CleantalkSP\SpbctWP\VulnerabilityAlarm\Exceptions\VulnerabilityAlarmServiceException;

class VulnerabilityAlarmService
{
    public static function updateVulnerabilitiesLibrary()
    {
        $modules = self::getModules();
        $report = self::getReport($modules);
        self::writeReport($report);
    }

    /**
     * @return array
     */
    public static function getVulnerabilitiesList()
    {
        $list = get_option(VulnerabilityAlarm::VULNERABILITY_LIST);

        if ( ! $list ) {
            return [];
        }

        return $list;
    }

    /**
     * @return void
     */
    public static function checkVulnerabilities()
    {
        // $list = get_option(VulnerabilityAlarm::VULNERABILITY_LIST);
        // if ( ! $list ) {
        //     return;
        // }

        // $modules = self::getModules();
        // $report = self::compare($modules, $list);
        // self::writeReport($report);
    }

    public static function checkPlugin($plugin_slug)
    {
        /** @var ApiResults|null $list */
        $list = get_option(VulnerabilityAlarm::VULNERABILITY_LIST);
        foreach ( $list->plugins as $plugin ) {
            if ( $plugin->app_name === $plugin_slug && $plugin->app_status === 'vulnerable' ) {
                return $plugin;
            }
        }
        return false;
    }

    /**
     * @param array $modules
     * @param array $list
     *
     * @psalm-suppress UnusedParam
     * @psalm-suppress UnusedMethod
     * @todo replace the suppressing above
     */
    private static function compare($modules, $list)
    {
    }

    /**
     * Gathering info about installed modules
     *
     * @return array
     */
    private static function getModules()
    {
        $modules = [
            'themes' => [],
            'plugins' => []
        ];

        require_once(ABSPATH . 'wp-admin/includes/plugin.php');
        require_once(ABSPATH . 'wp-admin/includes/theme.php');

        $plugins = get_plugins();
        $themes = wp_get_themes();

        foreach ($themes as $theme) {

            $modules['themes'][] = [
                $theme->get_stylesheet(),
                $theme->get('Version')
            ];
        }

        foreach ($plugins as $plugin) {
            $modules['plugins'][] = [
                sanitize_title($plugin['Name']),
                $plugin['Version']
            ];
        }

        return $modules;
    }

    /**
     * Get info about vulnerabilities from cloud
     *
     * @param $modules array
     *
     * @return ApiResults
     *
     * @throws VulnerabilityAlarmServiceException
     */
    private static function getReport($modules)
    {
        if ( ! is_array($modules) ) {
            throw new VulnerabilityAlarmServiceException('Modules not provided.');
        }

        $modules_names = [];
        foreach ( $modules as $module_types ) {
            if ( is_array($module_types) ) {
                foreach ( $module_types as $module ) {
                    if ( isset($module[0]) ) {
                        $modules_names[] = $module[0];
                    }
                }
            }
        }

        if ( empty($modules_names) ) {
            throw new VulnerabilityAlarmServiceException('Modules names not found.');
        }

        $api_res = ResearchApi::method__research_list(json_encode($modules_names));

        if ( isset($api_res['error']) ) {
            throw new VulnerabilityAlarmServiceException('API error: ' . $api_res['error']);
        }

        // Convert API request to the usable format
        $results = static::mapApiResults($api_res);

        return $results;
    }

    /**
     * Save vulnerability info
     */
    private static function writeReport($report)
    {
        update_option(VulnerabilityAlarm::VULNERABILITY_LIST, $report);
    }

    /**
     * @param $api_res
     *
     * @return ApiResults
     */
    private static function mapApiResults($api_res)
    {
        $results = new ApiResults();
        foreach ( $api_res as $res ) {
            if ( isset($res['app_type'], $res['app_name'], $res['app_status']) ) {
                switch ( $res['app_type'] ) {
                    case 'plugin' :
                    default:
                        $report = new PluginReport();
                        break;
                    case 'theme' :
                        $report = new ThemeReport();
                        break;
                }

                if ( ! isset($report) ) {
                    continue;
                }

                $report->app_name = $res['app_name'];
                $report->app_status = $res['app_status'];
                if ( isset( $res['id'] ) ) {
                    $report->id = $res['id'];
                }
                if ( isset( $res['CVE'] ) ) {
                    $report->CVE = $res['CVE'];
                }
                if ( isset( $res['date'] ) ) {
                    $report->date = $res['date'];
                }
                if ( isset( $res['rs_app_version_min'] ) ) {
                    $report->rs_app_version_min = $res['rs_app_version_min'];
                }
                if ( isset( $res['rs_app_version_max'] ) ) {
                    $report->rs_app_version_max = $res['rs_app_version_max'];
                }

                // generates `$results->plugins` or `$results->themes`
                $res_type = $res['app_type'] . 's';
                $results->{$res_type}[] = $report;
            }
        }
        return $results;
    }
}
