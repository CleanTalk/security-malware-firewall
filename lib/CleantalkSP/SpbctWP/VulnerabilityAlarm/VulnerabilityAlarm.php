<?php

namespace CleantalkSP\SpbctWP\VulnerabilityAlarm;

use CleantalkSP\SpbctWP\VulnerabilityAlarm\Dto\ApiResults;
use CleantalkSP\SpbctWP\VulnerabilityAlarm\Exceptions\VulnerabilityAlarmServiceException;

class VulnerabilityAlarm
{
    const VULNERABILITY_LIST = 'spbc_vulnerabilities';

    /**
     * @var array
     */
    public static $plugins = [];

    /**
     * Get vulnerabilities from cloud and write to storage
     * @throws VulnerabilityAlarmServiceException
     */
    public static function checkVulnerabilities()
    {
        VulnerabilityAlarmService::updateVulnerabilitiesLibrary();
    }

    public static function checkPluginVulnerability($plugin_slug, $plugin_version)
    {
        /** @var ApiResults|null $list */
        $list = get_option(self::VULNERABILITY_LIST);
        if ( $list === false ) {
            return false;
        }
        static::$plugins = $list->plugins;
        return VulnerabilityAlarmService::checkPlugin($plugin_slug, $plugin_version);
    }

    public static function checkThemeVulnerability($slugs)
    {
        $theme_names = array();
        for ($i = 0; $i < count($slugs); $i++) {
            $arr_slug_and_version = [$slugs[$i++]];
            array_push($theme_names, $arr_slug_and_version);
        }

        return VulnerabilityAlarmService::getVulnerabilityThemes($theme_names);
    }

    public static function showAlarm($plugin_file, $plugin_data)
    {
        return VulnerabilityAlarmView::showPluginAlarm($plugin_file, $plugin_data);
    }

    public static function showThemeAlarm()
    {
        return VulnerabilityAlarmView::showThemeAlarm();
    }

    /**
     * @param array $themes
     *
     * @return array
     * @psalm-suppress PossiblyUnusedParam
     */
    public static function getSafeThemes($themes)
    {
        $theme_names = array();
        for ($i = 0; $i < count($themes); $i++) {
            $arr_slug = [$themes[$i]];
            array_push($theme_names, $arr_slug);
        }
        return VulnerabilityAlarmService::getSafeThemes($theme_names);
    }

    /**
     * @param array $plugins
     *
     * @return array
     */
    public static function getSafePlugins($plugins)
    {
        $safe_plugins = [];
        $plugins_to_cloud = [];

        // Prepare data to the cloud call
        foreach ( $plugins as $plugin ) {
            $slug = static::getPluginSlug($plugin);
            if ( !empty($slug) ) {
                $plugins_to_cloud[] = [$slug];
            }
        }

        // Get cloud report about plugins
        try {
            $report = VulnerabilityAlarmService::getReport(['plugins' => $plugins_to_cloud]);
        } catch (\Exception $_exception) {
            return $safe_plugins;
        }

        if ( count($report->plugins) ) {
            static::$plugins = $report->plugins;
            foreach ( $plugins as $plugin ) {
                $plugin_slug = static::getPluginSlug($plugin);
                $plugin_version = static::getPluginVersion($plugin);
                $plugin_check = VulnerabilityAlarmService::checkPlugin($plugin_slug, $plugin_version, true);
                if ( $plugin_check ) {
                    $plugin_id = static::getPluginId($plugin_slug);
                    $safe_plugins = ['slug' => $plugin_slug, 'id' => $plugin_id];
                }
            }
        }
        return $safe_plugins;
    }

    public static function getPluginId($plugin_slug)
    {
        if ( empty($plugin_slug) ) {
            return false;
        }
        $id = '';
        foreach ( VulnerabilityAlarm::$plugins as $plugin ) {
            if ( $plugin->slug === $plugin_slug && $plugin->app_status === 'safe') {
                $id = $plugin->id;
            }
        }
        return $id;
    }

    private static function getPluginSlug($plugin)
    {
        $slug = '';
        if ( !is_array($plugin) ) {
            if ( gettype($plugin) === 'object' ) {
                if ( property_exists($plugin, 'slug') ) {
                    $slug = $plugin->slug;
                } elseif ( property_exists($plugin, 'name') ) {
                    $slug = $plugin->name;
                }
            }
        } else {
            $slug = isset($plugin['slug']) ? $plugin['slug'] : sanitize_title($plugin['Name']);
        }
        return $slug;
    }

    private static function getPluginVersion($plugin)
    {
        $version = '';
        if ( !is_array($plugin) ) {
            if ( gettype($plugin) === 'object' ) {
                if (property_exists($plugin, 'version')) {
                    $version = $plugin->version;
                }
            }
        } else {
            $version = isset($plugin['version']) ? $plugin['version'] : '';
        }
        return $version;
    }

    public static function showSafeBadge($module_type = 'plugin', $plugin_slug = '', $plugin_id = '')
    {
        return VulnerabilityAlarmView::showSafeBadge($module_type, $plugin_slug, $plugin_id);
    }

    public static function checkOne($module, $version)
    {
        $report = VulnerabilityAlarmService::getReport([[[$module]]]);
        if (!isset($report->plugins[0])) {
            return false;
        }

        return VulnerabilityAlarmService::isPluginVersionIsVulnerable($report->plugins[0], $version);
    }

    /**
     * Render tab for spbct settings page
     * @psalm-suppress PossiblyUnusedMethod
     * @todo replace the suppressing above
     */
    public static function renderTab()
    {
    }

    /**
     * Send report to cloud about installed vulnerability modules on site
     * @psalm-suppress PossiblyUnusedMethod
     * @todo replace the suppressing above
     */
    public static function sendReport()
    {
    }
}
