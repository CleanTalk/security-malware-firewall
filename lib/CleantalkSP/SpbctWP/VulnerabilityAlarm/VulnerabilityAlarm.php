<?php

namespace CleantalkSP\SpbctWP\VulnerabilityAlarm;

use CleantalkSP\SpbctWP\VulnerabilityAlarm\Dto\ApiResults;
use CleantalkSP\SpbctWP\VulnerabilityAlarm\Dto\ThemeReport;
use CleantalkSP\SpbctWP\VulnerabilityAlarm\Exceptions\VulnerabilityAlarmServiceException;

class VulnerabilityAlarm
{
    const VULNERABILITY_LIST = 'spbc_vulnerabilities';

    /**
     * @var array
     */
    public static $plugins = [];

    /**
     * @var array
     */
    public static $themes = [];

    /**
     * * * * Common * * *
     */

    /**
     * Get vulnerabilities from cloud and write to storage
     * @throws VulnerabilityAlarmServiceException
     */
    public static function updateWPModulesVulnerabilities()
    {
        VulnerabilityAlarmService::updateVulnerabilitiesLibrary();
    }

    /**
     * Send report to cloud about installed vulnerability modules on site
     * @psalm-suppress PossiblyUnusedMethod
     * @todo replace the suppressing above
     */
    public static function sendReport()
    {
    }

    public static function showSafeBadge($module_type = 'plugin', $plugin_slug = '', $plugin_id = '')
    {
        return VulnerabilityAlarmView::showSafeBadge($module_type, $plugin_slug, $plugin_id);
    }

    /**
     * * * * Plugins * * *
     */

    /**
     * @param $plugin_slug
     * @param $plugin_version
     * @return Dto\PluginReport|ThemeReport|false
     */
    public static function checkPluginVulnerabilityStatic($plugin_slug, $plugin_version)
    {
        /** @var ApiResults|null $list */
        $list = get_option(self::VULNERABILITY_LIST);
        if ( $list === false ) {
            return false;
        }
        static::$plugins = $list->plugins;
        return VulnerabilityAlarmService::getPluginReportStatic($plugin_slug, $plugin_version, false);
    }

    public static function getPluginAlarmHTML($plugin_file, $plugin_data)
    {
        return VulnerabilityAlarmView::showPluginAlarm($plugin_file, $plugin_data);
    }

    /**
     * Filters and returns a list of safe plugins based on a cloud report.
     *
     * This method processes an array of plugins to determine their safety by consulting a cloud-based report.
     * It first extracts the slugs of all provided plugins and prepares them for a cloud report request. After
     * fetching the report, it iterates over the original plugin list and checks each plugin against the report
     * to determine if it is considered safe. A plugin is deemed safe if it is found in the report with a positive
     * safety check. The method returns an array of safe plugins, each represented by an associative array containing
     * the plugin's slug and its unique identifier.
     *
     * @param array $plugins An array of plugins to be checked for safety. Each plugin should be an associative array
     *                       or object containing at least a 'slug' and 'version' key.
     * @return array An array of safe plugins. Each element in the array is an associative array containing the
     *               'slug' and 'id' of the safe plugin.
     */
    public static function getSafePluginsViaAPI($plugins)
    {
        $safe_plugins = [];
        $plugins_to_cloud = [];

        // Prepare data to the cloud call
        foreach ( $plugins as $plugin ) {
            $slug = static::getPluginSlug($plugin);
            if ( !empty($slug) ) {
                $plugins_to_cloud[] = [$slug];
            }
        }

        // Get cloud report about plugins
        try {
            $report = VulnerabilityAlarmService::getReport(['plugins' => $plugins_to_cloud]);
        } catch (\Exception $_exception) {
            return $safe_plugins;
        }

        // Check if the cloud report contains any plugins.
        if ( count($report->plugins) ) {
            // Update the static $plugins property with the report's plugin data.
            static::$plugins = $report->plugins;
            // Iterate over each plugin provided to the method.
            foreach ( $plugins as $plugin ) {
                // Retrieve the slug of the current plugin.
                $plugin_slug = static::getPluginSlug($plugin);
                // Retrieve the version of the current plugin.
                $plugin_version = static::getPluginVersion($plugin);
                // Check if the current plugin is considered safe based on the cloud report.
                $plugin_check = VulnerabilityAlarmService::getPluginReportStatic($plugin_slug, $plugin_version, true);
                // If the plugin is safe, proceed to add it to the list of safe plugins.
                if ( $plugin_check ) {
                    // Retrieve the ID of the current plugin.
                    $plugin_id = static::getPluginId($plugin_slug);
                    // Add the plugin to the list of safe plugins with its slug and ID.
                    $safe_plugins[] = ['slug' => $plugin_slug, 'id' => $plugin_id];
                }
            }
        }
        return $safe_plugins;
    }

    /**
     * Retrieves a list of plugins certified by the Security Team.
     *
     * This method first fetches all installed plugins using the `get_plugins()` function. It then filters these plugins
     * through the `getSafePlugins()` method to identify those that are considered safe. Among the safe plugins, it further
     * filters to identify those that have been specifically certified by the Plugin Security Checker (PSC), indicating
     * a higher level of security assurance. The PSC certification is determined by checking the `app_status` and `psc`
     * properties of each plugin's report data.
     *
     * @return array An array of plugins that are both considered safe and have PSC certification. Each element in the
     *               array is an associative array containing the plugin's ID in WP system, plugin slug, and PSC certificate name.
     */
    public static function getPSCSafePluginsOnly()
    {
        $installed_plugins = get_plugins();
        $safe_plugins = VulnerabilityAlarm::getSafePluginsViaAPI($installed_plugins);

        $psc_safe_plugins = array();
        // Iterate over each plugin considered safe
        foreach ($safe_plugins as $safe_plugin) {
            // Check if the static $plugins property is not empty and is an array
            if (!empty(static::$plugins) && is_array(static::$plugins)) {
                // Iterate over each plugin in the static $plugins property
                foreach (static::$plugins as $report_plugin) {
                    // Check if the current plugin from the report matches the safe plugin by slug,
                    // has a status of 'safe_psc', and has a non-null PSC certification
                    if (
                        $report_plugin->slug === $safe_plugin['slug'] &&
                        $report_plugin->app_status === 'safe_psc' &&
                        $report_plugin->psc !== null
                    ) {
                        // If the conditions are met, add the plugin to the list of PSC safe plugins
                        // including its ID, slug, and PSC certification
                        $psc_safe_plugins[] = array(
                            'id' => $safe_plugin['id'],
                            'slug' => $safe_plugin['slug'],
                            'psc' => $report_plugin->psc,
                            'version' => !empty($report_plugin->rs_app_version_min) ? $report_plugin->rs_app_version_min : 'unknown'
                        );
                    }
                }
            }
        }
        return $psc_safe_plugins;
    }

    public static function getPluginId($plugin_slug)
    {
        if ( empty($plugin_slug) ) {
            return false;
        }
        $id = '';
        foreach ( VulnerabilityAlarm::$plugins as $plugin ) {
            if ( $plugin->slug === $plugin_slug && $plugin->app_status === 'safe') {
                $id = $plugin->id;
            }
        }
        return $id;
    }

    private static function getPluginSlug($plugin)
    {
        $slug = '';
        if ( !is_array($plugin) ) {
            if ( gettype($plugin) === 'object' ) {
                if ( property_exists($plugin, 'slug') ) {
                    $slug = $plugin->slug;
                } elseif ( property_exists($plugin, 'name') ) {
                    $slug = $plugin->name;
                }
            }
        } else {
            $slug = isset($plugin['slug']) ? $plugin['slug'] : sanitize_title($plugin['Name']);
        }
        return $slug;
    }

    private static function getPluginVersion($plugin)
    {
        $version = '';
        if ( !is_array($plugin) ) {
            if ( gettype($plugin) === 'object' ) {
                if (property_exists($plugin, 'version')) {
                    $version = $plugin->version;
                }
            }
        } else {
            $version = isset($plugin['version']) ? $plugin['version'] : '';
            $version = empty($version) && isset($plugin['Version']) ? $plugin['Version'] : $version;
        }
        return $version;
    }

    public static function checkSinglePluginViaAPI($module, $version)
    {
        $report = VulnerabilityAlarmService::getReport([[[$module]]]);
        if (!isset($report->plugins[0])) {
            return false;
        }

        return VulnerabilityAlarmService::isModuleVersionIsVulnerable($report->plugins[0], $version);
    }

    /**
     * * * * Themes * * *
     */

    public static function getVulnerableThemesViaAPI($slugs)
    {
        $themes_data = array();
        foreach ($slugs as $theme) {
            if (isset($theme['slug'], $theme['version'])) {
                $themes_data[] = array($theme['slug'], $theme['version']);
            }
        }

        return VulnerabilityAlarmService::checkVulnerableThemesViaAPI($themes_data);
    }

    public static function checkSingleThemeVulnerabilityStatic($theme_slug, $theme_version)
    {
        /** @var ApiResults|null $list */
        $list = get_option(self::VULNERABILITY_LIST);
        if ( $list === false ) {
            return false;
        }
        static::$themes = $list->themes;
        return VulnerabilityAlarmService::getThemeReportStatic($theme_slug, $theme_version);
    }

    /**
     * Displays an alarm for a theme identified as vulnerable.
     *
     * This method is a wrapper around the VulnerabilityAlarmView::showThemeAlarm() method. It is responsible for
     * displaying an alarm for a theme that has been identified as vulnerable. The method takes a theme report object
     * as its parameter, which contains details about the theme's vulnerability. The actual display logic and UI rendering
     * are handled by the VulnerabilityAlarmView::showThemeAlarm() method, to which this method delegates by passing
     * the theme report object.
     *
     * @param ThemeReport $theme_report An object containing the theme's details, including its vulnerability information.
     * @return string The string result of the VulnerabilityAlarmView::showThemeAlarm() method call
     */
    public static function getThemeAlarmHTML($theme_report)
    {
        return VulnerabilityAlarmView::showThemeAlarm($theme_report);
    }

    /**
     * @param array $themes
     *
     * @return array
     * @psalm-suppress PossiblyUnusedParam
     */
    public static function getSafeThemesViaApi($themes)
    {
        $theme_names = array();
        for ($i = 0; $i < count($themes); $i++) {
            $arr_slug = [$themes[$i]];
            array_push($theme_names, $arr_slug);
        }
        return VulnerabilityAlarmService::getSafeThemesViaAPI($theme_names);
    }
}
