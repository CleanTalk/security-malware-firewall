<?php

namespace CleantalkSP\Common\Helpers;

use CleantalkSP\Common\Helper;
use CleantalkSP\Templates\Singleton;
use CleantalkSP\Variables\Server;

class HelperHTTP {
    
    use Singleton;
    
    /**
     * Default user agent for HTTP requests
     */
    const AGENT = 'Cleatalk-Helper/3.6';
    
    /**
     * @var array Stored HTTP headers
     */
    private $headers     = array();
    
    /**
     * Gets every HTTP_ headers from $_SERVER
     *
     * If Apache web server is missing then making
     * Patch for apache_request_headers()
     *
     * returns array
     */
    public static function getHTTPHeaders(){
        
        // If headers already return them
        $headers = self::getInstance()->headers;
        if( ! empty( $headers ) ){
            return $headers;
        }
        
        foreach($_SERVER as $key => $val){
            if( 0 === stripos( $key, 'http_' ) ){
                $server_key = preg_replace('/^http_/i', '', $key);
                $key_parts = explode('_', $server_key);
                if(count($key_parts) > 0 and strlen($server_key) > 2){
                    foreach($key_parts as $part_index => $part){
                        if( $part_index === '' || $part === '' ){
                            continue;
                        }
                        $key_parts[$part_index] = function_exists('mb_strtolower') ? mb_strtolower($part) : strtolower($part);
                        $key_parts[$part_index][0] = strtoupper($key_parts[$part_index][0]);
                    }
                    $server_key = implode('-', $key_parts);
                }
                $headers[$server_key] = $val;
            }
        }
        
        // Store headers to skip the work next time
        self::getInstance()->headers = $headers;
        
        return $headers;
    }
    
    /**
     * Function sends raw http request
     *
     * May use 4 presets(combining possible):
     * get_code - getting only HTTP response code
     * async    - async requests
     * get      - GET-request
     * ssl      - use SSL
     *
     * @param string       $url     URL
     * @param array        $data    POST|GET indexed array with data to send
     * @param string|array $presets String or Array with presets: get_code, async, get, ssl, dont_split_to_array
     * @param array        $opts    Optional option for CURL connection
     *
     * @return array|bool (array || array('error' => true))
     * @todo Have to replace this method to the new class like HttpHelper
     */
    public static function request($url, $data = array(), $presets = null, $opts = array())
    {
        
        $url = self::append_parameters_to_URL( $url, 'spbc_no_cache=' . mt_rand( 0, mt_getrandmax() ) );
        
        if(function_exists('curl_init')){
            
            $ch = curl_init();
            
            if(!empty($data)){
                // If $data scalar converting it to array
                $data = is_string($data) || is_int($data) ? array($data => 1) : $data;
                // Build query
                $opts[CURLOPT_POSTFIELDS] = $data;
            }
            
            // Merging OBLIGATORY options with GIVEN options
            $opts = HelperArray::merge__save_numeric_keys(
                array(
                    CURLOPT_URL => $url,
                    CURLOPT_TIMEOUT => 15,
                    CURLOPT_LOW_SPEED_TIME => 10,
                    CURLOPT_RETURNTRANSFER => true,
                    CURLOPT_CONNECTTIMEOUT => 6000,
                    CURLOPT_FORBID_REUSE => true,
                    CURLOPT_USERAGENT => self::AGENT . '; ' . ( Server::get('SERVER_NAME') ?: 'UNKNOWN_HOST'),
                    CURLOPT_POST => true,
                    CURLOPT_SSL_VERIFYPEER => false,
                    CURLOPT_SSL_VERIFYHOST => 0,
                    CURLOPT_HTTPHEADER => array(
                        'Expect:', // Fix for large data and old servers http://php.net/manual/ru/function.curl-setopt.php#82418
                        'Expires: '.date(DATE_RFC822, mktime(0, 0, 0, 1, 1, 1971)),
                        'Cache-Control: no-store, no-cache, must-revalidate',
                        'Cache-Control: post-check=0, pre-check=0',
                        'Pragma: no-cache',
                    ),
                    CURLOPT_FOLLOWLOCATION => true,
                    CURLOPT_MAXREDIRS => 5,
                ),
                $opts
            );
            
            // Use presets
            $presets = is_array($presets) ? $presets : explode(' ', $presets);
            foreach($presets as $preset){
                
                switch($preset){
                    
                    // Do not follow redirects
                    case 'dont_follow_redirects':
                        $opts[CURLOPT_FOLLOWLOCATION] = false;
                        $opts[CURLOPT_MAXREDIRS] = 0;
                        break;
                    
                    // Get headers only
                    case 'get_code':
                        $opts[CURLOPT_HEADER] = true;
                        $opts[CURLOPT_NOBODY] = true;
                        break;
                    
                    // Make a request, don't wait for an answer
                    case 'async':
                        $opts[CURLOPT_CONNECTTIMEOUT] = 3;
                        $opts[CURLOPT_TIMEOUT] = 3;
                        break;
                    
                    case 'get':
                        $opts[CURLOPT_URL] = self::append_parameters_to_URL( $opts[CURLOPT_URL], $data );
                        $opts[CURLOPT_CUSTOMREQUEST] = 'GET';
                        $opts[CURLOPT_POST] = false;
                        $opts[CURLOPT_POSTFIELDS] = null;
                        break;
                    
                    case 'ssl':
                        $opts[CURLOPT_SSL_VERIFYPEER] = true;
                        $opts[CURLOPT_SSL_VERIFYHOST] = 2;
                        if(defined('CLEANTALK_CASERT_PATH') && CLEANTALK_CASERT_PATH)
                            $opts[CURLOPT_CAINFO] = CLEANTALK_CASERT_PATH;
                        break;
                    
                    default:
                        
                        break;
                }
                
            }
            unset($preset);
            
            curl_setopt_array($ch, $opts);
            $result = curl_exec($ch);
            
            // RETURN if async request
            if(in_array('async', $presets))
                return true;
            
            if( $result !== false ){
                
                if( strpos( $result, PHP_EOL ) !== false && ! in_array( 'dont_split_to_array', $presets, true ) ){
                    $result = explode( PHP_EOL, $result );
                }
                
                // Get code crossPHP method
                if( in_array( 'get_code', $presets, true ) ){
                    $curl_info = curl_getinfo($ch);
                    $result = $curl_info['http_code'];
                }
                curl_close($ch);
                $out = $result;
            }else
                $out = array('error' => curl_error($ch));
        }else
            $out = array('error' => 'CURL_NOT_INSTALLED');
        
        /**
         * Getting HTTP-response code without cURL
         */
        if($presets && ($presets == 'get_code' || (is_array($presets) && in_array('get_code', $presets)))
           && isset($out['error']) && $out['error'] == 'CURL_NOT_INSTALLED'
        ){
            $headers = get_headers($url);
            $out = (int)preg_replace('/.*(\d{3}).*/', '$1', $headers[0]);
        }
        
        return $out;
    }
    
    /**
     * Do multi curl requests without processing it.
     *
     * @param array    $urls Array of URLs to requests
     * @param callable $callback callback to process results
     *
     * @return array
     * @psalm-suppress PossiblyUnusedMethod
     */
    public static function multi_request_pure( $urls, $callback = null )
    {
        if( ! is_array( $urls ) || empty( $urls ) ) {
            return array( 'error' => 'CURL_MULTI: Parameter is not an array.' );
        }
        
        foreach( $urls as $url ) {
            if( ! is_string( $url ) ) {
                return array( 'error' => 'CURL_MULTI: Parameter elements must be strings.' );
            }
        }
        
        $urls_count = count( $urls );
        $curl_arr = array();
        $mh = curl_multi_init();
        
        for($i = 0; $i < $urls_count; $i++)
        {
            $url =$urls[$i];
            $curl_arr[$i] = curl_init($url);
            $opts = array(
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_CONNECTTIMEOUT => 10,
                CURLOPT_FORBID_REUSE => true,
                CURLOPT_USERAGENT => self::AGENT . '; ' . ( isset( $_SERVER['REMOTE_ADDR'] ) ? $_SERVER['REMOTE_ADDR'] : 'UNKNOWN_HOST' ),
                CURLOPT_HTTPHEADER => array('Expect:'), // Fix for large data and old servers http://php.net/manual/ru/function.curl-setopt.php#82418
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_MAXREDIRS => 5,
            );
            curl_setopt_array($curl_arr[$i], $opts);
            curl_multi_add_handle($mh, $curl_arr[$i]);
        }
        
        do {
            curl_multi_exec($mh,$running);
            usleep(200);
        } while($running > 0);
        
        for($i = 0, $results = array(); $i < $urls_count; $i++){
            
            $response_code = curl_getinfo($curl_arr[$i], CURLINFO_HTTP_CODE);
            
            if( 200 === (int)$response_code ){
                
                $content   = curl_multi_getcontent( $curl_arr[$i] );
                
                // Run callback if passed and valid
                if( is_callable( $callback ) ){
                    $content = call_user_func( $callback, $content );
                }
                
                $results[] = $content;
            }else{
                $results[] = array('error' => 'BAD_RESPONSE_CODE: ' . $response_code);
            }
        }
        
        return $results;
    }
    
    /**
     * Do multi curl requests.
     *
     * @param array $urls      Array of URLs to requests
     * @param string $write_to Path to the writing files dir
     *
     * @return array
     * @psalm-suppress PossiblyUnusedMethod
     */
    public static function multi_request( $urls, $write_to = '' )
    {
        if( ! is_array( $urls ) || empty( $urls ) ) {
            return array( 'error' => 'CURL_MULTI: Parameter is not an array.' );
        }
        
        foreach( $urls as $url ) {
            if( ! is_string( $url ) ) {
                return array( 'error' => 'CURL_MULTI: Parameter elements must be strings.' );
            }
        }
        
        $urls_count = count( $urls );
        $curl_arr = array();
        $master = curl_multi_init();
        
        for($i = 0; $i < $urls_count; $i++)
        {
            $url =$urls[$i];
            $curl_arr[$i] = curl_init($url);
            $opts = array(
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_CONNECTTIMEOUT_MS => 10000,
                CURLOPT_FORBID_REUSE => true,
                CURLOPT_USERAGENT => self::AGENT . '; ' . ( isset( $_SERVER['REMOTE_ADDR'] ) ? $_SERVER['REMOTE_ADDR'] : 'UNKNOWN_HOST' ),
                CURLOPT_HTTPHEADER => array('Expect:'), // Fix for large data and old servers http://php.net/manual/ru/function.curl-setopt.php#82418
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_MAXREDIRS => 5,
            );
            curl_setopt_array($curl_arr[$i], $opts);
            curl_multi_add_handle($master, $curl_arr[$i]);
        }
        
        do {
            curl_multi_exec($master,$running);
            // @ToDo place here sleep(500) to avoid possible CPU overusing
        } while($running > 0);
        
        $results = array();
        
        for($i = 0; $i < $urls_count; $i++)
        {
            $info = curl_getinfo($curl_arr[$i], CURLINFO_HTTP_CODE);
            if( 200 == $info ) {
                if( ! empty( $write_to ) && is_dir( $write_to ) && is_writable( $write_to ) ) {
                    $results[] = file_put_contents(  $write_to . Helper::getFilenameFromUrl( $urls[$i] ), curl_multi_getcontent( $curl_arr[$i] ) )
                        ? 'success'
                        : 'error';
                } else {
                    $results[] = curl_multi_getcontent( $curl_arr[$i] );
                }
                
            } else {
                $results[] = 'error';
            }
        }
        return $results;
    }
    
    
    /**
     * Appends given parameter(s) to URL considering other parameters
     * Adds ? or & before the append
     *
     * @param string       $url
     * @param string|array $parameters
     *
     * @return string
     */
    public static function append_parameters_to_URL( $url, $parameters ){
        
        $parameters = is_array( $parameters )
            ? http_build_query( $parameters )
            : $parameters;
        
        $url .= strpos( $url, '?' ) === false
            ? ('?' . $parameters)
            : ('&' . $parameters);
        
        return $url;
    }
}