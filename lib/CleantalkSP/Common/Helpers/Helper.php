<?php


namespace CleantalkSP\Common\Helpers;


class Helper
{
    /**
	 * Resolve DNS to a single IP-address
	 *
	 * @param string $host
	 * @param bool   $out
	 *
	 * @return bool
	 */
	public static function resolveDNS($host, $out = false)
	{
		// Get DNS records about URL
		if(function_exists('dns_get_record')){
			$records = @dns_get_record($host, DNS_A);
			if($records !== false){
				$out = $records[0]['ip'];
			}
		}
		
		// Another try if first failed
		if(!$out && function_exists('gethostbynamel')){
			$records = gethostbynamel($host);
			if($records !== false){
				$out = $records[0];
			}
		}
		
		return $out;
		
	}
    
    /**
     * Return the start of the given time interval in seconds
     *
     * @param int $interval Duration of the interval
     *
     * @return int
     */
    public static function getTimeIntervalStart( $interval = 300 ){
		return time() - ( ( time() - strtotime( date( 'd F Y' ) ) ) % $interval );
	}

    /**
     * Checks for invalid UTF8 in a string.

     * @param string $string The text which is to be checked.
     * @param bool   $strip  Optional. Whether to attempt to strip out invalid UTF8. Default false.
     * @return string The checked text.
     */
    public static function checkInvalidUTF8( $string, $strip = false ) {
        $string = (string) $string;

        if ( 0 === strlen( $string ) ) {
            return '';
        }

        // Check for support for utf8 in the installed PCRE library once and store the result in a static.
        static $utf8_pcre = null;
        if ( ! isset( $utf8_pcre ) ) {
            // phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
            $utf8_pcre = @preg_match( '/^./u', 'a' );
        }
        // We can't demand utf8 in the PCRE installation, so just return the string in those cases.
        if ( ! $utf8_pcre ) {
            return $string;
        }

        // phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged -- preg_match fails when it encounters invalid UTF8 in $string.
        if ( 1 === @preg_match( '/^./us', $string ) ) {
            return $string;
        }

        // Attempt to strip the bad chars if requested (not recommended).
        if ( $strip && function_exists( 'iconv' ) ) {
            return iconv( 'utf-8', 'utf-8', $string );
        }

        return '';
    }

    /**
     * Converts a number of special characters into their HTML entities.
     *
     * Specifically deals with: `&`, `<`, `>`, `"`, and `'`.
     *
     * `$quote_style` can be set to ENT_COMPAT to encode `"` to
     * `&quot;`, or ENT_QUOTES to do both. Default is ENT_NOQUOTES where no quotes are encoded.
     *
     * @param string       $string        The text which is to be encoded.
     * @param int|string   $quote_style   Optional. Converts double quotes if set to ENT_COMPAT,
     *                                    both single and double if set to ENT_QUOTES or none if set to ENT_NOQUOTES.
     *                                    Converts single and double quotes, as well as converting HTML
     *                                    named entities (that are not also XML named entities) to their
     *                                    code points if set to ENT_XML1. Also compatible with old values;
     *                                    converting single quotes if set to 'single',
     *                                    double if set to 'double' or both if otherwise set.
     *                                    Default is ENT_NOQUOTES.
     * @param false|string $charset       Optional. The character encoding of the string. Default false.
     * @param bool         $double_encode Optional. Whether to encode existing HTML entities. Default false.
     * @return string The encoded text with HTML entities.
     */
    public static function convertToSpecialchars( $string, $quote_style = ENT_NOQUOTES ) {
        $string = (string) $string;

        if ( 0 === strlen( $string ) ) {
            return '';
        }

        // Don't bother if there are no specialchars - saves some processing.
        if ( ! preg_match( '/[&<>"\']/', $string ) ) {
            return $string;
        }

        // Account for the previous behaviour of the function when the $quote_style is not an accepted value.
        if ( empty( $quote_style ) ) {
            $quote_style = ENT_NOQUOTES;
        } elseif ( ENT_XML1 === $quote_style ) {
            $quote_style = ENT_QUOTES | ENT_XML1;
        } elseif ( ! in_array( $quote_style, array( ENT_NOQUOTES, ENT_COMPAT, ENT_QUOTES, 'single', 'double' ), true ) ) {
            $quote_style = ENT_QUOTES;
        }

        $_quote_style = $quote_style;

        if ( 'double' === $quote_style ) {
            $quote_style  = ENT_COMPAT;
            $_quote_style = ENT_COMPAT;
        } elseif ( 'single' === $quote_style ) {
            $quote_style = ENT_NOQUOTES;
        }

        $string = htmlspecialchars( $string, $quote_style );

        // Back-compat.
        if ( 'single' === $_quote_style ) {
            $string = str_replace( "'", '&#039;', $string );
        }

        return $string;
    }

    /**
     * Performs a deep string replace operation to ensure the values in $search are no longer present.
     *
     * Repeats the replacement operation until it no longer replaces anything so as to remove "nested" values
     * e.g. $subject = '%0%0%0DDD', $search ='%0D', $result ='' rather than the '%0%0DD' that
     * str_replace would return
     * @param string|array $search  The value being searched for, otherwise known as the needle.
     *                              An array may be used to designate multiple needles.
     * @param string       $subject The string being searched and replaced on, otherwise known as the haystack.
     * @return string The string with the replaced values.
     */
    public static function deepReplace( $search, $subject ) {
        $subject = (string) $subject;

        $count = 1;
        while ( $count ) {
            $subject = str_replace( $search, '', $subject, $count );
        }

        return $subject;
    }

    /**
     * Retrieve a list of protocols to allow in HTML attributes.
     *
     * @return string[] Array of allowed protocols. Defaults to an array containing 'http', 'https',
     *                  'ftp', 'ftps', 'mailto', 'news', 'irc', 'irc6', 'ircs', 'gopher', 'nntp', 'feed',
     *                  'telnet', 'mms', 'rtsp', 'sms', 'svn', 'tel', 'fax', 'xmpp', 'webcal', and 'urn'.
     *                  This covers all common link protocols, except for 'javascript' which should not
     *                  be allowed for untrusted users.
     */
    public static function getAllowedProtocols() {
        return array(
            'http',
            'https',
            'ftp',
            'ftps',
            'mailto',
            'news',
            'irc',
            'irc6',
            'ircs',
            'gopher',
            'nntp',
            'feed',
            'telnet',
            'mms',
            'rtsp',
            'sms',
            'svn',
            'tel',
            'fax',
            'xmpp',
            'webcal',
            'urn'
        );
    }
}