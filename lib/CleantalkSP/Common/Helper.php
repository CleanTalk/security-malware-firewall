<?php

namespace CleantalkSP\Common;

use CleantalkSP\Variables\Server;
use CleantalkSP\Templates\Singleton;
use CleantalkSP\Common\Validate;

/**
 * CleanTalk Helper class.
 * Compatible with any CMS.
 *
 * @package       PHP Antispam by CleanTalk
 * @subpackage    Helper
 * @Version       3.7
 * @author        Cleantalk team (welcome@cleantalk.org)
 * @copyright (C) 2014 CleanTalk team (http://cleantalk.org)
 * @license       GNU/GPL: http://www.gnu.org/copyleft/gpl.html
 * @see           https://github.com/CleanTalk/php-antispam
 */
class Helper
{
	
	use Singleton;
	
	/**
	 * Default user agent for HTTP requests
	 */
	const AGENT = 'Cleatalk-Helper/3.6';
	
	/**
	 * Resolve DNS to IP
	 *
	 * @param      $host
	 * @param bool $out
	 *
	 * @return bool
	 */
	public static function dns__resolve($host, $out = false)
	{
		
		// Get DNS records about URL
		if(function_exists('dns_get_record')){
			$records = @dns_get_record($host, DNS_A);
			if($records !== false){
				$out = $records[0]['ip'];
			}
		}
		
		// Another try if first failed
		if(!$out && function_exists('gethostbynamel')){
			$records = gethostbynamel($host);
			if($records !== false){
				$out = $records[0];
			}
		}
		
		return $out;
		
	}
	
	/**
	 * Function sends raw http request
	 *
	 * May use 4 presets(combining possible):
	 * get_code - getting only HTTP response code
	 * async    - async requests
	 * get      - GET-request
	 * ssl      - use SSL
	 *
	 * @param string       $url     URL
	 * @param array        $data    POST|GET indexed array with data to send
	 * @param string|array $presets String or Array with presets: get_code, async, get, ssl, dont_split_to_array
	 * @param array        $opts    Optional option for CURL connection
	 *
	 * @return array|bool (array || array('error' => true))
	 * @todo Have to replace this method to the new class like HttpHelper
	 */
	public static function request($url, $data = array(), $presets = null, $opts = array())
	{
        
        $url = self::appendParametersToURL($url, 'spbc_no_cache=' . mt_rand(0, mt_getrandmax() ) );
	    
		if(function_exists('curl_init')){
			
			$ch = curl_init();
			
			if(!empty($data)){
				// If $data scalar converting it to array
				$data = is_string($data) || is_int($data) ? array($data => 1) : $data;
				// Build query
				$opts[CURLOPT_POSTFIELDS] = $data;
			}
			
			// Merging OBLIGATORY options with GIVEN options
			$opts = self::array_merge__save_numeric_keys(
				array(
					CURLOPT_URL => $url,
                    CURLOPT_TIMEOUT => 15,
                    CURLOPT_LOW_SPEED_TIME => 10,
					CURLOPT_RETURNTRANSFER => true,
					CURLOPT_CONNECTTIMEOUT => 6000,
					CURLOPT_FORBID_REUSE => true,
					CURLOPT_USERAGENT => self::AGENT . '; ' . ( Server::get('SERVER_NAME') ?: 'UNKNOWN_HOST'),
					CURLOPT_POST => true,
					CURLOPT_SSL_VERIFYPEER => false,
					CURLOPT_SSL_VERIFYHOST => 0,
					CURLOPT_HTTPHEADER => array(
						'Expect:', // Fix for large data and old servers http://php.net/manual/ru/function.curl-setopt.php#82418
						'Expires: '.date(DATE_RFC822, mktime(0, 0, 0, 1, 1, 1971)),
						'Cache-Control: no-store, no-cache, must-revalidate',
						'Cache-Control: post-check=0, pre-check=0',
						'Pragma: no-cache',
					),
					CURLOPT_FOLLOWLOCATION => true,
					CURLOPT_MAXREDIRS => 5,
				),
				$opts
			);
			
			// Use presets
			$presets = is_array($presets) ? $presets : explode(' ', $presets);
			foreach($presets as $preset){
				
				switch($preset){
					
					// Do not follow redirects
					case 'dont_follow_redirects':
						$opts[CURLOPT_FOLLOWLOCATION] = false;
						$opts[CURLOPT_MAXREDIRS] = 0;
						break;
					
					// Get headers only
					case 'get_code':
						$opts[CURLOPT_HEADER] = true;
						$opts[CURLOPT_NOBODY] = true;
						break;
					
					// Make a request, don't wait for an answer
					case 'async':
						$opts[CURLOPT_CONNECTTIMEOUT] = 3;
						$opts[CURLOPT_TIMEOUT] = 3;
						break;
					
					case 'get':
						$opts[CURLOPT_URL] = self::appendParametersToURL($opts[CURLOPT_URL], $data );
						$opts[CURLOPT_CUSTOMREQUEST] = 'GET';
						$opts[CURLOPT_POST] = false;
						$opts[CURLOPT_POSTFIELDS] = null;
						break;
					
					case 'ssl':
						$opts[CURLOPT_SSL_VERIFYPEER] = true;
						$opts[CURLOPT_SSL_VERIFYHOST] = 2;
						if(defined('CLEANTALK_CASERT_PATH') && CLEANTALK_CASERT_PATH)
							$opts[CURLOPT_CAINFO] = CLEANTALK_CASERT_PATH;
						break;
						
					default:
						
						break;
				}
				
			}
			unset($preset);
			
			curl_setopt_array($ch, $opts);
			$result = curl_exec($ch);
			
			// RETURN if async request
			if(in_array('async', $presets))
				return true;
			
            if( $result !== false ){
                
                if( strpos( $result, PHP_EOL ) !== false && ! in_array( 'dont_split_to_array', $presets, true ) ){
                    $result = explode( PHP_EOL, $result );
                }
				
				// Get code crossPHP method
				if( in_array( 'get_code', $presets, true ) ){
					$curl_info = curl_getinfo($ch);
					$result = $curl_info['http_code'];
				}
				curl_close($ch);
				$out = $result;
			}else
				$out = array('error' => curl_error($ch));
		}else
			$out = array('error' => 'CURL_NOT_INSTALLED');
		
		/**
		 * Getting HTTP-response code without cURL
		 */
		if($presets && ($presets == 'get_code' || (is_array($presets) && in_array('get_code', $presets)))
			&& isset($out['error']) && $out['error'] == 'CURL_NOT_INSTALLED'
		){
			$headers = get_headers($url);
			$out = (int)preg_replace('/.*(\d{3}).*/', '$1', $headers[0]);
		}
		
		return $out;
	}
    
    /**
     * Do multi curl requests without processing it.
     *
     * @param array    $urls Array of URLs to requests
     * @param callable $callback callback to process results
     *
     * @return array
     * @psalm-suppress PossiblyUnusedMethod
     */
    public static function requestMulti( $urls, $callback = null )
    {
        if( ! is_array( $urls ) || empty( $urls ) ) {
            return array( 'error' => 'CURL_MULTI: Parameter is not an array.' );
        }
        
        foreach( $urls as $url ) {
            if( ! is_string( $url ) ) {
                return array( 'error' => 'CURL_MULTI: Parameter elements must be strings.' );
            }
        }
        
        $urls_count = count( $urls );
        $curl_arr = array();
        $mh = curl_multi_init();
        
        for($i = 0; $i < $urls_count; $i++)
        {
            $url =$urls[$i];
            $curl_arr[$i] = curl_init($url);
            $opts = array(
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_CONNECTTIMEOUT => 10,
                CURLOPT_FORBID_REUSE => true,
                CURLOPT_USERAGENT => self::AGENT . '; ' . ( isset( $_SERVER['REMOTE_ADDR'] ) ? $_SERVER['REMOTE_ADDR'] : 'UNKNOWN_HOST' ),
                CURLOPT_HTTPHEADER => array('Expect:'), // Fix for large data and old servers http://php.net/manual/ru/function.curl-setopt.php#82418
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_MAXREDIRS => 5,
            );
            curl_setopt_array($curl_arr[$i], $opts);
            curl_multi_add_handle($mh, $curl_arr[$i]);
        }
        
        do {
            curl_multi_exec($mh,$running);
            usleep(200);
        } while($running > 0);
        
        for($i = 0, $results = array(); $i < $urls_count; $i++){
            
            $response_code = curl_getinfo($curl_arr[$i], CURLINFO_HTTP_CODE);
            
            if( 200 === (int)$response_code ){
                
                $content   = curl_multi_getcontent( $curl_arr[$i] );
                
                // Run callback if passed and valid
                if( is_callable( $callback ) ){
                    $content = call_user_func( $callback, $content );
                }
                
                $results[] = $content;
            }else{
                $results[] = array('error' => 'BAD_RESPONSE_CODE: ' . $response_code);
            }
        }
        
        return $results;
    }
    
    /**
     * Do multi curl requests.
     *
     * @param array $urls      Array of URLs to requests
     * @param string $write_to Path to the writing files dir
     *
     * @return array
     * @psalm-suppress PossiblyUnusedMethod
     */
    public static function requestMultiForFirewall( $urls, $write_to = '' )
    {
        if( ! is_array( $urls ) || empty( $urls ) ) {
            return array( 'error' => 'CURL_MULTI: Parameter is not an array.' );
        }
        
        foreach( $urls as $url ) {
            if( ! is_string( $url ) ) {
                return array( 'error' => 'CURL_MULTI: Parameter elements must be strings.' );
            }
        }
        
        $urls_count = count( $urls );
        $curl_arr = array();
        $master = curl_multi_init();
        
        for($i = 0; $i < $urls_count; $i++)
        {
            $url =$urls[$i];
            $curl_arr[$i] = curl_init($url);
            $opts = array(
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_CONNECTTIMEOUT_MS => 10000,
                CURLOPT_FORBID_REUSE => true,
                CURLOPT_USERAGENT => self::AGENT . '; ' . ( isset( $_SERVER['REMOTE_ADDR'] ) ? $_SERVER['REMOTE_ADDR'] : 'UNKNOWN_HOST' ),
                CURLOPT_HTTPHEADER => array('Expect:'), // Fix for large data and old servers http://php.net/manual/ru/function.curl-setopt.php#82418
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_MAXREDIRS => 5,
            );
            curl_setopt_array($curl_arr[$i], $opts);
            curl_multi_add_handle($master, $curl_arr[$i]);
        }
        
        do {
            curl_multi_exec($master,$running);
            // @ToDo place here sleep(500) to avoid possible CPU overusing
        } while($running > 0);
        
        $results = array();
        
        for($i = 0; $i < $urls_count; $i++)
        {
            $info = curl_getinfo($curl_arr[$i], CURLINFO_HTTP_CODE);
            if( 200 == $info ) {
                if( ! empty( $write_to ) && is_dir( $write_to ) && is_writable( $write_to ) ) {
                    $results[] = file_put_contents(  $write_to . self::getFilenameFromUrl( $urls[$i] ), curl_multi_getcontent( $curl_arr[$i] ) )
                        ? 'success'
                        : 'error';
                } else {
                    $results[] = curl_multi_getcontent( $curl_arr[$i] );
                }
                
            } else {
                $results[] = 'error';
            }
        }
        return $results;
    }
    
    
    /**
	 * Appends given parameter(s) to URL considering other parameters
	 * Adds ? or & before the append
	 *
	 * @param string       $url
	 * @param string|array $parameters
	 *
	 * @return string
	 */
	public static function appendParametersToURL( $url, $parameters ){
		
		$parameters = is_array( $parameters )
			? http_build_query( $parameters )
			: $parameters;
		
		$url .= strpos( $url, '?' ) === false
			? ('?' . $parameters)
			: ('&' . $parameters);
		
		return $url;
	}
	
	
	/**
	 * Gets every HTTP_ headers from $_SERVER
	 *
	 * If Apache web server is missing then making
	 * Patch for apache_request_headers()
	 *
	 * returns array
	 */
	public static function getHeaders(){
		
		// If headers already return them
		$headers = self::getInstance()->headers;
		if( ! empty( $headers ) ){
			return $headers;
		}
		
		foreach($_SERVER as $key => $val){
			if( 0 === stripos( $key, 'http_' ) ){
				$server_key = preg_replace('/^http_/i', '', $key);
				$key_parts = explode('_', $server_key);
				if(count($key_parts) > 0 and strlen($server_key) > 2){
					foreach($key_parts as $part_index => $part){
						if( $part_index === '' || $part === '' ){
							continue;
						}
						$key_parts[$part_index] = function_exists('mb_strtolower') ? mb_strtolower($part) : strtolower($part);
						$key_parts[$part_index][0] = strtoupper($key_parts[$part_index][0]);
					}
					$server_key = implode('-', $key_parts);
				}
				$headers[$server_key] = $val;
			}
		}
		
		// Store headers to skip the work next time
		self::getInstance()->headers = $headers;
		
		return $headers;
	}
    
    
    /**
     * @param array $arr
     *
     * @return bool
     */
    public static function array_reindex( &$arr )
    {
        if( ! count( $arr ) ){
            return false;
        }
        
        for( $reindex_key = 0, $key = 0, $max_key = max( array_keys( $arr ) ); $key <= $max_key; $key++ ){
            
            if( isset( $arr[ $key ] ) ){
                
                if( $reindex_key === $key ){
                    $reindex_key++;
                    continue;
                }
                
                $arr[ $reindex_key++ ] = $arr[ $key ];
                unset( $arr[ $key ] );
            }
        }
        
        return true;
    }
	
	/**
	 * Merging arrays without reseting numeric keys
	 *
	 * @param array $arr1 One-dimentional array
	 * @param array $arr2 One-dimentional array
	 *
	 * @return array Merged array
	 */
	public static function array_merge__save_numeric_keys($arr1, $arr2)
	{
		foreach($arr2 as $key => $val){
			$arr1[$key] = $val;
		}
		return $arr1;
	}
	
	/**
	 * Merging arrays without reseting numeric keys recursive
	 *
	 * @param array $arr1 One-dimentional array
	 * @param array $arr2 One-dimentional array
	 *
	 * @return array Merged array
	 */
	public static function array_merge__save_numeric_keys__recursive($arr1, $arr2)
	{
		foreach($arr2 as $key => $val){
			// Array | array => array
			if(isset($arr1[$key]) && is_array($arr1[$key]) && is_array($val)){
				$arr1[$key] = self::array_merge__save_numeric_keys__recursive($arr1[$key], $val);
				// Scalar | array => array
			}elseif(isset($arr1[$key]) && !is_array($arr1[$key]) && is_array($val)){
				$tmp = $arr1[$key] =
				$arr1[$key] = $val;
				$arr1[$key][] = $tmp;
				// array  | scalar => array
			}elseif(isset($arr1[$key]) && is_array($arr1[$key]) && !is_array($val)){
				$arr1[$key][] = $val;
				// scalar | scalar => scalar
			}else{
				$arr1[$key] = $val;
			}
		}
		return $arr1;
	}
	
	/**
	 * Modifies the array $array. Paste $insert on $position
	 *
	 * @param array      $array
	 * @param int|string $position
	 * @param mixed      $insert
	 */
	public static function array_insert( &$array, $position, $insert ){
		if( is_int( $position ) ){
			array_splice( $array, $position, 0, $insert );
		}else{
			$pos   = array_search( $position, array_keys( $array ) );
			$array = array_merge(
				array_slice( $array, 0, $pos ),
				$insert,
				array_slice( $array, $pos )
			);
		}
	}
	
	
	/**
	 * Function removing non UTF8 characters from array|string|object
	 *
	 * @param array|object|string $data
	 *
	 * @return array|object|string
	 */
	public static function removeNonUTF8($data)
	{
		// Array || object
		if(is_array($data) || is_object($data)){
			foreach($data as $key => &$val){
				$val = self::removeNonUTF8($val);
			}
			unset($key, $val);
			
			//String
		}else{
			if(!preg_match('//u', $data))
				$data = 'Nulled. Not UTF8 encoded or malformed.';
		}
		return $data;
	}
	
	/**
	 * Function convert anything to UTF8 and removes non UTF8 characters
	 *
	 * @param array|object|string $obj
	 * @param string              $data_codepage
	 *
	 * @return mixed(array|object|string)
	 */
	public static function toUTF8($obj, $data_codepage = null)
	{
		// Array || object
		if(is_array($obj) || is_object($obj)){
			foreach($obj as $key => &$val){
				$val = self::toUTF8($val, $data_codepage);
			}
			unset($key, $val);
			
			//String
		}else{
			if(!preg_match('//u', $obj) && function_exists('mb_detect_encoding') && function_exists('mb_convert_encoding')){
				$encoding = mb_detect_encoding($obj);
				$encoding = $encoding ? $encoding : $data_codepage;
				if($encoding)
					$obj = mb_convert_encoding($obj, 'UTF-8', $encoding);
			}
		}
		return $obj;
	}
	
	/**
	 * Function convert from UTF8
	 *
	 * @param array|object|string $obj
	 * @param string              $data_codepage
	 *
	 * @return mixed (array|object|string)
	 */
	public static function fromUTF8($obj, $data_codepage = null)
	{
		// Array || object
		if(is_array($obj) || is_object($obj)){
			foreach($obj as $key => &$val){
				$val = self::fromUTF8($val, $data_codepage);
			}
			unset($key, $val);
			
			//String
		}else{
			if(preg_match('u', $obj) && function_exists('mb_convert_encoding') && $data_codepage !== null)
				$obj = mb_convert_encoding($obj, $data_codepage, 'UTF-8');
		}
		return $obj;
	}
	
	/**
	 * Checks if the string is JSON type
	 *
	 * @param string
	 *
	 * @return bool
	 */
	public static function is_json($string)
	{
		return is_string($string) && is_array(json_decode($string, true)) ? true : false;
	}
	
	/**
	 * Get mime type from file or data
	 *
	 * @param string $data Path to file or data
	 * @param string $type Default mime type. Returns if we failed to detect type
	 *
	 * @return string
	 */
	public static function get_mime_type( $data, $type = '' )
	{
		$data = str_replace( chr(0), '', $data ); // Clean input of null bytes
		if( ! empty( $data ) && @file_exists( $data )){
			$type = mime_content_type( $data );
		}elseif( function_exists('finfo_open' ) ){
			$finfo = finfo_open(FILEINFO_MIME_TYPE);
			$type = finfo_buffer($finfo, $data);
			finfo_close($finfo);
		}
		return $type;
	}
	
	public static function buffer__trim_and_clear_from_empty_lines( $buffer ){
		$buffer = (array) $buffer;
		foreach( $buffer as $indx => &$line ){
			$line = trim( $line );
			if($line === '')
				unset( $buffer[$indx] );
		}
		return $buffer;
	}
	
	/**
	 * Parse Comma-separated values
	 *
	 * @param $buffer
	 *
	 * @return false|string[]
	 */
	public static function buffer__parse__csv( $buffer ){
		$buffer = explode( "\n", $buffer );
		$buffer = self::buffer__trim_and_clear_from_empty_lines( $buffer );
		foreach($buffer as &$line){
		    
		    if( $line !== '' ){
                $line = str_getcsv( $line, ',', '\'' );
            }
		    
		}
		return $buffer;
	}
	
	/**
	 * Parse Newline-separated values
	 *
	 * @param $buffer
	 *
	 * @return false|string[]
	 */
	public static function buffer__parse__nsv( $buffer ){
		$buffer = str_replace( array( "\r\n", "\n\r", "\r", "\n" ), "\n", $buffer );
		$buffer = explode( "\n", $buffer );
		return $buffer;
	}
	
	/**
	 * Pops line from buffer without formatting
	 *
	 * @param $csv
	 *
	 * @return false|string
	 */
	public static function buffer__csv__pop_line( &$csv ){
		$pos  = strpos( $csv, "\n" );
		$line = substr( $csv, 0, $pos );
		$csv  = substr_replace( $csv, '', 0, $pos + 1 );
		return $line;
	}
	
	/**
	 * Pops line from the csv buffer and fromat it by map to array
	 *
	 * @param $csv
	 * @param array $map
	 *
	 * @return array|false
	 */
	public static function buffer__csv__get_map( &$csv )
    {
		$line = static::buffer__csv__pop_line( $csv );
		
		// Validate each element of the map
        $map = array();
		foreach( explode( ',', $line ) as $elem ){
		    if( Validate::isWord($elem) ){
		        $map[] = $elem;
            }else{
		        return array('error' => 'CSV_BAD_MAP_ELEM');
            }
        }
		
		return $map ?: array('error' => 'CSV_EMPTY_MAP');
	}

	/**
	 * Pops line from the csv buffer and fromat it by map to array
	 *
	 * @param $csv
	 * @param array $map
	 *
	 * @return array|false
	 */
	public static function buffer__csv__pop_line_to_array( &$csv, $map = array() ){
		$line = trim( static::buffer__csv__pop_line( $csv ) );
		$line = strpos( $line, '\'' ) === 0
			? str_getcsv($line, ',', '\'')
			: explode( ',', $line );
		if( $map )
			$line = array_combine( $map, $line );
		return $line;
	}

	/**
	 * Universal method to adding cookies
	 *
	 * @param $name
	 * @param string $value
	 * @param int $expires
	 * @param string $path
	 * @param null $domain
	 * @param bool $secure
	 * @param bool $httponly
	 * @param string $samesite
	 *
	 * @return bool   Result of setcookie()
	 */
	public static function cookie_set ($name, $value = '', $expires = 0, $path = '', $domain = null, $secure = false, $httponly = false, $samesite = 'Lax' ) {

		// For PHP 7.3+ and above
		if( version_compare( phpversion(), '7.3.0', '>=' ) ){

			$params = array(
				'expires'  => $expires,
				'path'     => $path,
				'domain'   => $domain,
				'secure'   => $secure,
				'httponly' => $httponly,
			);

			if($samesite)
				$params['samesite'] = $samesite;

			$res = setcookie( $name, $value, $params );

			// For PHP 5.6 - 7.2
		}else {
			$res = setcookie( $name, $value, $expires, $path, $domain, $secure, $httponly );
		}

		return $res;

	}
    
    /**
     * @param $url string
     *
     * @return string
     */
    public static function getFilenameFromUrl( $url )
    {
        $array = explode( '/', $url );
        return end( $array );
    }
    
    /**
     * Recursive
     *
     * @param $dir_path string The directory path to delete
     *
     * @return bool
     */
    public static function fs__removeDirectoryRecursively( $dir_path ) {
    
        if( is_dir( $dir_path ) && is_writable( $dir_path ) ) {
        
            $files = glob( $dir_path . '/*' );
        
            if( ! empty( $files ) ) {
                foreach( $files as $file ){
                    
                    if( ! is_writable( $file ) ){
                        return false;
                    }
                        
                    if( is_file( $file ) && ! unlink( $file ) ){
                        return false;
                    }
                    
                    if( is_dir( $file ) && ! self::fs__removeDirectoryRecursively( $file ) ) {
                        return false;
                    }

                }
            }
        
            return rmdir( $dir_path );
        
        }
        
        return true;
    
    }
    
    /**
     * @param $path string The filesystem path to delete anything
     *
     * @return bool
     */
    public static function fs__removeAnything( $path ) {
    
        if( ! is_writable( $path ) ){
            return false;
        }
    
        if( is_file( $path ) ){
            return unlink( $path );
        }

        if( is_dir( $path ) ){
            return self::fs__removeDirectoryRecursively( $path );
        }
        
        return true;
        
    }
}