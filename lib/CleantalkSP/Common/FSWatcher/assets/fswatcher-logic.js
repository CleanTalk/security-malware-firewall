// if no changes detected after comparison
let noFSWChangesDetected = true;
// first selector elem
const firstFSWSelector = document.getElementById('fswatcher__first_date');
// second selector elem
const secondFSWSelector = document.getElementById('fswatcher__second_date');
// FSW table body
const fsWatcherTableBody = document.getElementById('spbc-table-fs_watcher-comparison');
// available types of events
const availableFSWDataSetNames = ['added','changed','deleted']

/**
 * Main handler function. Run this on the button click.
 * @param {Event} e click event.
 */
function FSWCompare(e) {
    e.preventDefault();

    let first_date = document.getElementById('fswatcher__first_date').value;
    let second_date = document.getElementById('fswatcher__second_date').value;

    toggleFSWSelectorsInfo(true);

    if (typeof fswatcherToken !== 'undefined') {
        let xhr = new XMLHttpRequest();
        xhr.open("POST", fswatcherWebsiteUrl + '/');
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
        let data = [
            'fswatcher_token=' + fswatcherToken,
            'fswatcher_compare=1',
            'fswatcher__first_date=' + first_date,
            'fswatcher__second_date=' + second_date,
        ];
        xhr.send(data.join('&'));
        xhr.onreadystatechange = function() {
            if( xhr.readyState == XMLHttpRequest.DONE && xhr.status == 200 ) {
                FSWHandleXHRResponse(xhr.response);
            }
        }
    }

    return false;
}

/**
 * Handle File System Watcher XHR Response
 * @param {string} response
 */
function FSWHandleXHRResponse(response) {
    let responseDataObj = {};
    noFSWChangesDetected = true;
    if (typeof response === 'string') {
        responseDataObj = FSWDecodeJSON(response)
        if (responseDataObj.hasOwnProperty('error')) {
            alert('File System watcher JSON parse error: see console for details.')
            console.log('File System watcher JSON parse error: ' + responseDataObj.error)
            return;
        }
    }

    const validate_result = validateFSWResponse(responseDataObj)
    if (true === validate_result) {
        renderFSWatcherTableContent(responseDataObj)
        if (noFSWChangesDetected) {
            renderFSWTableRow( '', 'no_changes', '')
        }
    } else {
        alert(validate_result + ' Please contact support@cleantalk.org');
        console.log('File System watcher response validating error: ' + validate_result)
    }
    resetFSWSelectors();
}

function FSWCreate(e) {
    e.preventDefault();
    if (typeof fswatcherToken !== 'undefined') {
        let xhr = new XMLHttpRequest();
        const button = e.target;
        button.disabled = true;
        xhr.open("POST", fswatcherWebsiteUrl + '/');
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
        let data = [
            'fswatcher_token=' + fswatcherToken,
            'fswatcher_create_snapshot=1'
        ];
        xhr.send(data.join('&'));
        xhr.onreadystatechange = function() {
            if( xhr.readyState == XMLHttpRequest.DONE && xhr.status == 200 ) {
                FSWHandleXHRResponseCreate(xhr.response, button);
            }
        }
    }
}

function FSWHandleXHRResponseCreate(response, button) {
    let responseDataObj = {};
    if (typeof response === 'string') {
        responseDataObj = FSWDecodeJSON(response);
        button.disabled = false;
    }

}

/**
 * Try to decode JSON string from site response.
 * @param {string} response
 */
function FSWDecodeJSON(response) {
    try {
        return JSON.parse(response)
    } catch (e) {
        return {'error': e};
    }
}

/**
 * Run rendering comparison table in dependence of response object
 * @param {{}} responseDataObj
 */
function renderFSWatcherTableContent(responseDataObj) {
    fsWatcherTableBody.innerHTML = '';
    for (const dataSetName of availableFSWDataSetNames) {
        if (handleFSWDataObject(responseDataObj, dataSetName))
        {
            noFSWChangesDetected = false;
        }
    }
}

function validateFSWResponse(responseDataObj) {
    if (
        !responseDataObj ||
        typeof responseDataObj !== 'object'
    ) {
        return 'Response is invalid.'
    }

    if (typeof responseDataObj.error !== 'undefined') {
        return responseDataObj.error
    }

    for (const dataSetName of availableFSWDataSetNames) {
        if (
            !responseDataObj.hasOwnProperty(dataSetName)
        ) {
            return 'Response has no required properties.'
        }
    }

    return true;
}

/**
 * @param {object} responseDataObj
 * @param {string|number} event_type
 */
function handleFSWDataObject(responseDataObj, event_type) {
    const events_array = responseDataObj[event_type]
    if (events_array.length > 0) {
        for (let i = 0; i < events_array.length; i++) {
            const row = convertFSWEventToRow(events_array[i], event_type);
            renderFSWTableRow(row.path, row.event_type, row.date)
        }
    } else {
        return false;
    }
    return true;
}

/**
 * Convert a row of site response to the formatted data.
 * @param {object} event contains the date and the file path
 * @param {string} event_type contains event type
 */
function convertFSWEventToRow(event, event_type) {
    let row = {
        'path': 'unknown',
        'event_type': event_type.toUpperCase(),
        'date': 'unknown'
    }

    if (event.length === 2) {
        if (typeof event[0] === 'string') {
            row.path = event[0];
        }
        if (typeof event[1] === 'string') {
            row.date = new Date(Number(event[1]) * 1000).toLocaleString();
        }
    }

    return row;
}


/**
 * Render the row of FSW table.
 * @param {string} path the file path
 * @param {string} event_type the event type
 * @param {string} date the date of event
 */
function renderFSWTableRow(path, event_type, date) {

    if (event_type === 'no_changes') {
        let tr = document.createElement('tr')
        let td = document.createElement('td')
        td.setAttribute('name', 'fswatcher-event-no-changes')
        td.setAttribute('colspan', '3')
        td.innerText = 'No changes detected on selected dates';
        tr.appendChild(td)
        fsWatcherTableBody.appendChild(tr);
        return;
    }

    let tr = document.createElement('tr')

    let td_path = document.createElement('td')
    td_path.setAttribute('name', 'fswatcher-event-path')
    td_path.innerText = path;
    tr.appendChild(td_path)

    let td_type = document.createElement('td')
    td_type.setAttribute('name', 'fswatcher-event-type')
    td_type.innerText = event_type;
    tr.appendChild(td_type)

    let td_date = document.createElement('td')
    td_date.setAttribute('name', 'fswatcher-event-date')
    td_date.innerText = date;
    tr.appendChild(td_date)

    fsWatcherTableBody.appendChild(tr);
}

/**
 * Filter options for the first selector and disable it to keep it from changes.
 */
function filterFSWSecondSelector() {
    toggleFSWSelectorsInfo(false);
    const first_select_value = firstFSWSelector.options[firstFSWSelector.selectedIndex].value
    if (!secondFSWSelector.disabled) {
        if (typeof first_select_value !== 'undefined') {
            for (let i = 0; i < secondFSWSelector.options.length; i++) {
                if (Number(secondFSWSelector.options[i].value) <= Number(first_select_value)) {
                    secondFSWSelector.options[i].style.display = 'none';
                }
            }
        }
        firstFSWSelector.setAttribute('disabled', 'disabled')
    }
}

/**
 * Filter options for the second selector and disable it to keep it from changes.
 */
function filterFSWFirstSelector() {
    const second_select_value = secondFSWSelector.options[secondFSWSelector.selectedIndex].value;
    toggleFSWSelectorsInfo(false);
    if (!firstFSWSelector.disabled) {
        if (typeof second_select_value !== 'undefined') {
            for (let i = 0; i < firstFSWSelector.options.length; i++) {
                if (Number(firstFSWSelector.options[i].value) >= Number(second_select_value)) {
                    firstFSWSelector.options[i].style.display = 'none';
                }
            }
        }
    }
    secondFSWSelector.setAttribute('disabled', 'disabled')
}

/**
 * Reset selectors to its initial statements.
 */
function resetFSWSelectors() {
    for (let i = 0; i < firstFSWSelector.options.length; i++) {
        firstFSWSelector.options[i].style.display = 'inherit';
    }
    for (let i = 0; i < secondFSWSelector.options.length; i++) {
        secondFSWSelector.options[i].style.display = 'inherit';
    }
    secondFSWSelector.removeAttribute('disabled');
    firstFSWSelector.removeAttribute('disabled');
}

/**
 * Toggle info string.
 * @param {boolean} enable Set logs names if true, disable content if false.
 */
function toggleFSWSelectorsInfo(enable) {
    let infoTag = document.getElementById('spbc--fs-watcher-table-handling-selects-info')
    if (enable) {
        infoTag.style.display = 'inherit';
        infoTag.innerHTML= 'Comparing log ' +
            '<b>' + firstFSWSelector.options[firstFSWSelector.selectedIndex].text + '</b>' +
            ' with log ' +
            '<b>' + secondFSWSelector.options[secondFSWSelector.selectedIndex].text + '</b>'
    } else {
        infoTag.innerText = '';
        infoTag.style.display = 'none';
    }
}

// listeners
document.getElementById('fswatcher__compare').addEventListener('click', FSWCompare);
document.getElementById('fswatcher__create_snapshot').addEventListener('click', FSWCreate);
firstFSWSelector.addEventListener('change', filterFSWSecondSelector);
secondFSWSelector.addEventListener('change', filterFSWFirstSelector);


