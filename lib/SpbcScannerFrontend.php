<?php

use CleantalkSP\SpbctWp\Helper as SpbcHelper;

class SpbcScannerFrontend
{
	// Counters
	public $posts_total   = 0;
	public $posts_checked = 0;	
	public $links_found   = 0;
	
	// Params
	public $check_default = false;
	
	// Work's stuff
	public $pages = array();        // Posts to check with ID and URI
	public $post_checked = array(); // Posts IDs that have been checked
	
	// Default pages to check
	private static $default_pages = array(
		'/index.php',
		'/wp-signup.php',
		'/wp-login.php',
	);
	
	private static $constructs = array(
		'test.test',
	);
	
	/**
	 * SpbcScannerLinks constructor.
	 *
	 * @param array $params
	 */
	function __construct($params = array())
	{
		// Setting params
		// Amount of pages to check in execution
		$amount    = isset($params['amount'])    ? $params['amount']    : 10;
		$last_scan = isset($params['last_scan']) ? $params['last_scan'] : date('Y-m-d H:i:s', time() - 86400 * 30);
		
		// Do all the work
		$this->get_pages_uri($amount, $last_scan);  // Get content to check
		
		if(!empty($this->pages)){
			$this->get_content();
		}
		
		if(!empty($this->pages)){
			$this->check();
		}
		
		if(count($this->post_checked))
			$this->post_mark_as_checked();
		
		// Count everything
		$this->posts_checked = count($this->pages);
	}
	
	/**
	 * Counts pages left to to check
	 *
	 * @param $last_scan
	 * @param string $type
	 * @param int    $out
	 *
	 * @return int
	 */
	public static function count_unchecked_pages($last_scan = null, $type = 'all', $out = 0)
	{
		global $wpdb;
		
		$last_scan = $last_scan	? $last_scan : date('Y-m-d H:i:s', time() - 86400 * 30);
		
		if(in_array($type, array('all', 'post'))){
			$sql = "SELECT COUNT(ID) as cnt
			FROM {$wpdb->posts} as posts
			WHERE
				post_status = 'publish' AND
				post_type IN ('post', 'page') AND
				NOT EXISTS(
					SELECT post_id, meta_key
						FROM {$wpdb->postmeta} as meta
						WHERE posts.ID = meta.post_id AND
							meta.meta_key = 'spbc_frontend__last_checked' AND
							meta.meta_value < '$last_scan'
				);";
			$posts = $wpdb->get_results($sql, ARRAY_A);
			$out += $posts[0]['cnt'];
		}
		
		// if(in_array($type, array('all', 'default'))){
		// 	$out += count(self::$default_pages);
		// }
		
		return $out;
	}
	
	/**
	 * Getting POSTS range with all approved comments
	 *
	 * @param $amount
	 * @param $last_scan
	 */
	public function get_pages_uri($amount, $last_scan)
	{
		global $wpdb;
		
		// Get page from POSTS table
		$sql = "SELECT guid, ID, post_type
			FROM {$wpdb->posts} as posts
			WHERE
				post_status = 'publish' AND
				post_type IN ('post', 'page') AND
				NOT EXISTS(
					SELECT post_id, meta_key
						FROM {$wpdb->postmeta} as meta
						WHERE posts.ID = meta.post_id AND
							meta.meta_key = 'spbc_frontend__last_checked' AND
							meta.meta_value < '$last_scan'
				)
			LIMIT $amount";
		$this->pages = $wpdb->get_results($sql, ARRAY_A);
		
		// Add default page to check only if 0 < posts to check > $amount
		// if(count($this->pages) < $amount  && count($this->pages) != 0){
		// 	foreach(self::$default_pages as $page){
		// 		$this->pages[] = array(
		// 			'guid' => $page,
		// 			'ID' => get_site_url() . $page,
		// 			'post_type' => 'default',
		// 		);
		// 	}
		// }
	}
	
	/**
	 * Get content. If $this->pages is not empty.
	 */
	public function get_content(){
		foreach($this->pages as $key => &$page){
			if(filter_var($page['guid'], FILTER_VALIDATE_URL)){
				if(SpbcHelper::http__request__get_response_code($page['guid']) == 200){
					$result = SpbcHelper::http__request__get_content($page['guid']);
					if(empty($result['error']))
						$this->pages[$key]['content'] = $result;
					else
						unset($this->pages[$key]);
				}
			}
		}
	}
	
	/**
	 * Checks current $content for malware.
	 * Calls subfunction for each malware type.
	 */
	public function check()
	{
		foreach ($this->pages as &$page){
			
			$dom = new DOMDocument();
			@$dom->loadHTML($page['content']);
			
			$page['bad'] = false;
			
			$result = $this->check__for_redirects($dom);
			$page['found']['redirects'] = $result ? 1 : 0;
			$page['bad'] = $result ? true : $page['bad'];
			
			$result = $this->check__for_driveByDownload($dom);
			$page['found']['dbd'] = $result ? 1 : 0;
			$page['bad'] = $result ? true : $page['bad'];
			
			// $result = $this->check__for_dangerousCode($dom);
			// if(isset($result['found'])){
			// 	$page['dagerous_code'] = true;
			// 	$page['found'] = $result['found'];
			// }
			// $result = $this->check__for_signatures($page['content']);
			// if(isset($result['found'])){
			// 	$page['signatures'] = true;
			// }
			
			$this->post_checked[] = $page['ID'];
		}
	}
	
	/**
	 * Check given data DOM Nodes for redirect signatures.
	 *
	 * @param $dom
	 *
	 * @return bool
	 */
	public function check__for_redirects($dom){
		
		// Getting JS tags to check
		$xpath = new DOMXPath($dom);
		$js = $xpath->evaluate("/html//script");
		
		// Getting signatures
		$home_url = parse_url(get_option('siteurl'), PHP_URL_HOST);
		$home_url = str_replace ('.', '\.', $home_url);
		
		return $this->check__for_anything(
			$js,
			'/location(?:\s*\.\s*href\s*)?\s*=\s*["\'](?:http[s]?:\/\/)(?:www)?(?!'.$home_url.')/',
			'reg_exp'
		);
	}
	
	public function check__for_driveByDownload($dom){
		// Getting JS tags to check
		$xpath = new DOMXPath($dom);
		$iframes = $xpath->evaluate("/html//iframe");
		$home_url = parse_url(get_option('siteurl'), PHP_URL_HOST);
		$needle = '/^(http[s]?:\/\/)?(wwww)?(?!'.$home_url.')/';
		foreach($iframes as $iframe){
			$src = $iframe->getAttribute('src');
			if($this->check__for_anything($src, $needle, 'reg_exp')){
				return true;
			}
		}
		return false;
	}
	
	public function check__for_dangerousCode($dom){
		
		// Getting JS tags to check
		$xpath = new DOMXPath($dom);
		$js = $xpath->evaluate("/html//script");
		
		$result = $this->check__for_anything($js, self::$constructs);
		return $result
			? array('found' => $result)
			: false;
	}
	
	public function check__for_signatures($content, $signatures){
		$result = $this->check__for_anything($content, $signatures);
		return $result
			? array('found' => $result)
			: false;
	}
	
	public function check__for_anything($haystacks, $needles, $search_type = 'string'){
		
		$haystacks = is_string($haystacks) ? array($haystacks) : $haystacks;
		$needles   = is_string($needles)   ? array($needles)   : $needles;
		
		foreach($haystacks as $haystack){
			
			// Getting text value for haystack
			$haystack = $haystack instanceof DOMElement
				? $haystack->nodeValue
				: $haystack;
			
			foreach($needles as $needle){
				
				// Getting type of search needle
				$search_type = !empty($needle['body_type'])
					? $needle['body_type']
					: $search_type;
				
				switch($search_type){
					
					// Check with strings
					case 'string':
						if(strpos($haystack, $needle) !== false){
							return $needle;
						}
						break;
					
					// Check with regular expression
					case 'reg_exp':
						if(preg_match($needle, $haystack)){
							return $needle;
						}
						break;
				}
			}
		}
		return false;
	}
	
	/**
	 * Mark checked pages
	 */
	public function post_mark_as_checked()
	{
		foreach($this->post_checked as $id){
			update_post_meta($id, 'spbc_frontend__last_checked', time());
		}
	}
	
}
