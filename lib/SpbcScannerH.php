<?php

/**
 * Class SpbcScannerH
 *
 * @package Security Plugin by CleanTalk
 * @subpackage Scanner
 * @Version 2.3
 * @author Cleantalk team (welcome@cleantalk.org)
 * @copyright (C) 2014 CleanTalk team (http://cleantalk.org)
 * @license GNU/GPL: http://www.gnu.org/copyleft/gpl.html
 * @see https://github.com/CleanTalk/security-malware-firewall
 */
class SpbcScannerH
{
	// Constants
	const FILE_MAX_SIZE = 524288; // 512 KB
	
	// Current file attributes
	public $is_text        = false;
	
	public $ext            = null; // File extension
	public $path           = null; // File path
	public $curr_dir       = null; // File path
	public $file_size      = 0;    // File size
	
	public $variables      = array();
	public $arrays         = array();
	public $constants      = array();
	public $variables_bad  = array();
	public $file_lexems    = array(); // Array with file lexems
	
	public $file_content   = '';   // Original
	public $file_work      = '';   // Work copy
	public $file_stamp     = '';
	
	public $includes       = array();
	public $sql_requests   = array();
	
	public $error = array();
	
	public $verdict = array(); // Scan results
	
	private $sequences = array(
		'define_constant' => array(
			array( 'T_STRING', 'define' ),
			'(',
			array( 'T_CONSTANT_ENCAPSED_STRING' ),
			',',
			array( 'T_CONSTANT_ENCAPSED_STRING' ) ),
		'array_equation_array' => array(
			'=',
			array( 'T_ARRAY' ),
			'(',
		),
		'array_equation_square_brackets' => array(
			'=',
			'[',
		)
	);
	
	private $variables_bad_default = array(
		'$_POST',
		'$_GET',
	);
	
	private $bad_constructs = array(
		'CRITICAL' => array(
			'eval',
			'assert',
			'create_function',
		),
		'DANGER' => array(
			'system',
			'passthru',
			'proc_open',
			'exec',
		),
		'SUSPICIOUS' => array(
			'base64_encode',
			'base64_decode',
			'str_rot13',
			'syslog',
		),
	);
	
	private $useless_lexems  = array(
		'T_INLINE_HTML',
		'T_COMMENT',
		'T_DOC_COMMENT',
		// 'T_WHITESPACE',
	);
	
	private $strip_whitespace_lexems  = array(
		'T_WHITESPACE', // /\s*/
		'T_CLOSE_TAG',
		'T_CONSTANT_ENCAPSED_STRING', // String in quotes
		// Equals
		'T_DIV_EQUAL',
		'T_BOOLEAN_OR',
		'T_BOOLEAN_AND',
		'T_IS_EQUAL',
		'T_IS_GREATER_OR_EQUAL',
		'T_IS_IDENTICAL',
		'T_IS_NOT_EQUAL',
		'T_IS_SMALLER_OR_EQUAL',
		'T_SPACESHIP',
		// Assignments
		'T_CONCAT_EQUAL',
		'T_MINUS_EQUAL',
		'T_MOD_EQUAL',
		'T_MUL_EQUAL',
		'T_AND_EQUAL',
		'T_OR_EQUAL',
		'T_PLUS_EQUAL',
		'T_POW_EQUAL',
		'T_SL_EQUAL',
		'T_SR_EQUAL',
		'T_XOR_EQUAL',
		// Bit
		'T_SL', // <<
		'T_SR', // >>
		// Uno
		'T_INC', // ++
		'T_DEC', // --
		'T_POW', // **
		// Cast type
		'T_ARRAY_CAST',
		'T_BOOL_CAST',
		'T_DOUBLE_CAST',
		'T_OBJECT_CAST',
		'T_STRING_CAST',
		// Different
		'T_START_HEREDOC', // <<<
		'T_NS_SEPARATOR', // \
		'T_ELLIPSIS', // ...
		'T_OBJECT_OPERATOR', // ->
		'T_DOUBLE_ARROW', // =>
		'T_DOUBLE_COLON', // ::
		'T_PAAMAYIM_NEKUDOTAYIM', // ::
	);
	
	private $equals_lexems = array(
		'=',
		'T_CONCAT_EQUAL',
		'T_MINUS_EQUAL',
		'T_MOD_EQUAL',
		'T_MUL_EQUAL',
		'T_AND_EQUAL',
		'T_OR_EQUAL',
		'T_PLUS_EQUAL',
		'T_POW_EQUAL',
		'T_SL_EQUAL',
		'T_SR_EQUAL',
		'T_XOR_EQUAL',
	);
	
	private $dont_trim_lexems = array(
		'T_ENCAPSED_AND_WHITESPACE',
		'T_OPEN_TAG',
	);
	
	private $variables_types_to_concat = array(
		'T_CONSTANT_ENCAPSED_STRING',
		// 'T_ENCAPSED_AND_WHITESPACE',
		'T_LNUMBER',
		'T_DNUMBER',
	);
	
	private $whitespace_lexem = array(
		'T_WHITESPACE',
		' ',
		null,
	);
	
	/**
	 * SpbcScannerH constructor.
	 * Getting common info about file|text and it's content
     *
	 * @param $path
	 * @param array $params
	 */
	public function __construct($path, $params = array())
	{
		// Exept file as a plain text|array
		if(isset($params['content'])){
			
			$this->is_text = true;
			$this->file_size    = strlen($params['content']);
			if($this->file_size != 0){
				if($this->file_size < self::FILE_MAX_SIZE){
					$this->file_work = $params['content'];
					$this->file_content = $this->file_work;
					$this->text_check = true;
					unset($params['content']);
				}else
					return $this->error = array('error' =>'FILE_SIZE_TO_LARGE');
			}else
				return $this->error = array('error' =>'FILE_SIZE_ZERO');
			
			// Except file as a path
		}elseif(!empty($path)){
			
			// Path
			$this->path     = $path;
			$this->curr_dir = dirname($this->path);
			
			// Extension
			$tmp = explode('/', $path);
			$tmp = explode('.', $tmp[count($tmp)-1]);
			$this->ext = $tmp[count($tmp)-1];
			
			if(file_exists($this->path)){
				if(is_readable($this->path)){
					$this->file_size = filesize($this->path);
					if($this->file_size > 0){
						if($this->file_size < self::FILE_MAX_SIZE){
							$this->file_work    = file_get_contents($this->path);
							$this->file_content = $this->file_work;
						}else
							return $this->error = array('error' =>'FILE_SIZE_TO_LARGE');
					}else
						return $this->error = array('error' =>'FILE_SIZE_ZERO');
				}else
					return $this->error = array('error' =>'FILE_NOT_READABLE');
			}else
				return $this->error = array('error' =>'FILE_NOT_EXISTS');
		}
	}
	
	public function process_file()
	{
		
		$this->file_lexems = @token_get_all($this->file_work);
		
		// Preparing file
		$this->lexems_getAll();
		
		$this->lexems_stripUseless();
		
		// Simplifying
		do{
			$this->file_stamp = $this->_stamp();
			
			$this->lexems_stripWhitespaces(); // Strips usless withspaces
			
			$this->processStrings();       // Convert to simple lexems strings
			$this->strings_concatenate();   // Concatenates nearby string lexems
			
			$this->variables_replaceSophisticatedCall();
			$this->variables_getAll();
			$this->variables_concatenate(); // Concatenates variable content if it's possible
			$this->variables_replace();     // Repaces variables with its content
			
			$this->decodeData();
			
			$this->file_lexems = array_values( $this->file_lexems );
			
		}while( $this->file_stamp !== $this->_stamp() );
		
		// Getting construction
		
		// Detecting bad variables
		$this->variables_detectBad();
		
		// Getting all include constructions and detecting bad
//        $this->includes_standardize();
		$this->includes_getAll();
		
		// Getting all MySQL requests and detecting bad
		$this->sql_requests_getAll();
		
		// Making verdict
		$this->make_verdict();

//		 $this->file_work = $this->gather_lexems();
	
	}
	
	// Strips Useless lexems. T_INLINE_HTML, T_COMMENT, T_DOC_COMMENT
	public function lexems_getAll()
	{
		foreach($this->file_lexems as $key => &$lexem){
			if(isset($lexem[1])){
				$lexem[0] = token_name( $lexem[0] );
			}
		}
	}
	
	// Strips Useless lexems. T_INLINE_HTML, T_COMMENT, T_DOC_COMMENT
	public function lexems_StripUseless()
	{
		for(
            $key = 0, $arr_size = count($this->file_lexems);
            $key < $arr_size;
            $key++
        ){
            // Unset useless lexems
			if( isset( $this->file_lexems[ $key ][0] ) && in_array( $this->file_lexems[ $key ][0], $this->useless_lexems, true ) ){
				unset( $this->file_lexems[ $key ] );
			}
		}
		$this->file_lexems = array_values($this->file_lexems);
	}
	
	// Strips T_WHITESPACE around (array)strip_whitespace_lexems and single lexems
	public function lexems_stripWhitespaces()
	{
		for(
            $key = 0,
            $current = null,
            $arr_size = count($this->file_lexems);

            $key < $arr_size;

            $key++,
            $current = isset($this->file_lexems[$key]) ? $this->file_lexems[$key] : null
        ){
		    // Deleting whitespaces
			if( isset( $current[0] ) && $current[0] === 'T_WHITESPACE'){
				
				$next = isset($this->file_lexems[$key+1]) ? $this->file_lexems[$key+1] : null;
				$prev = isset($this->file_lexems[$key-1]) ? $this->file_lexems[$key-1] : null;
				
				// Delete whitespace at all if possible
				if(
                    ( $next && ! is_array( $next ) ) ||
                    ( $prev && ! is_array( $prev ) ) ||
                    ( isset( $next[0] ) && in_array( $next[0], $this->strip_whitespace_lexems, true ) ) ||
                    ( isset( $prev[0] ) && in_array( $prev[0], $this->strip_whitespace_lexems, true ) )
                ){
					unset($this->file_lexems[$key]);
					
                // Or replace it with a sing space
				}else{
					$this->file_lexems[$key][1] = ' ';
				}
				
            // Trim whitespaces for all type of lexems, except denied to trim whitespaces
			}elseif( is_array( $this->file_lexems[ $key ] ) && ! in_array( $this->file_lexems[ $key ][0], $this->dont_trim_lexems, true ) ){
				$this->file_lexems[ $key ][1] = trim( $this->file_lexems[ $key ][1] );
			}
		}
		$this->file_lexems = array_values($this->file_lexems);
	}
	
	// Coverts T_ENCAPSED_AND_WHITESPACE to T_CONSTANT_ENCAPSED_STRING if could
	public function processStrings()
	{
		for(
			$key = 0,
			$current = null,
			$arr_size = count($this->file_lexems);
			
			$key < $arr_size;
			
			$key++,
			$current = isset($this->file_lexems[$key]) ? $this->file_lexems[$key] : null
		){
			
			// Delete T_ENCAPSED_AND_WHITESPACE
			if( $current && $current[0] === 'T_ENCAPSED_AND_WHITESPACE' ){
				$next = isset( $this->file_lexems[ $key + 1 ] ) ? $this->file_lexems[ $key + 1 ] : null;
				$prev = isset( $this->file_lexems[ $key - 1 ] ) ? $this->file_lexems[ $key - 1 ] : null;
				if( $prev === '"' && $next === '"' ){
					
					unset( $this->file_lexems[ $key - 1 ], $this->file_lexems[ $key + 1 ] );
					
					$this->file_lexems[ $key ] = array(
						'T_CONSTANT_ENCAPSED_STRING',
						'\'' . $current[1] . '\'',
						$current[2],
					);
				}
			}
			
			// Convert chr('\xNN') to 'a'
			elseif( $current && $current === ')' ){
				$prev  = isset( $this->file_lexems[ $key - 1 ] ) ? $this->file_lexems[ $key - 1 ] : null;
				$prev2 = isset( $this->file_lexems[ $key - 2 ] ) ? $this->file_lexems[ $key - 2 ] : null;
				$prev3 = isset( $this->file_lexems[ $key - 3 ] ) ? $this->file_lexems[ $key - 3 ] : null;
				if (
					isset( $prev[0] ) && in_array( $prev[0], array( 'T_LNUMBER', 'T_CONSTANT_ENCAPSED_STRING' ) ) &&
					$prev2 === '(' &&
					isset( $prev3[0] ) && $prev3[0] === 'T_STRING' && $prev3[1] === 'chr'
				) {
					unset(
						$this->file_lexems[ $key - 1 ],
						$this->file_lexems[ $key - 2 ],
						$this->file_lexems[ $key - 3 ]
					);
					$char_num                  = (int) trim( $prev[1], '\'"' );
					$this->file_lexems[ $key ] = array(
						'T_CONSTANT_ENCAPSED_STRING',
						'\'' . ( chr( $char_num ) ?: '' ) . '\'',
						$prev3[2],
					);
				}

				// Convert "\xNN" to 'a'
			}elseif(
				is_array( $current ) &&
				$current[0] === 'T_CONSTANT_ENCAPSED_STRING' &&
				( isset( $current[1][0] ) && $current[1][0] === '"' ) &&
				preg_match( '@\\\\[a-zA-Z\d]{3}@', $current[1] )
			){
				preg_match_all( '@(\\\\[a-zA-Z\d]{3})@', $current[1], $matches );
				$matches      = $matches[0];
				$replacements = array_map( static function( $elem ){
					return eval( "return \"$elem\";" );
				}, $matches );
				$this->file_lexems[ $key ][1] = str_replace( $matches, $replacements, $current[1] );
			}
			
			// @todo
			// Do the substr
//			if( $current[0] === 'T_STRING' && $current[1] === 'substr' && $next2[0] === 'T_CONSTANT_ENCAPSED_STRING' && $next4 === ){
//
//          }
		
		}
	}
	
	// Concatenates T_CONSTANT_ENCAPSED_STRING if could
	public function strings_concatenate()
	{
		for(
			$key = 0,
			$current = null,
			$arr_size = count( $this->file_lexems );
			
			$key < $arr_size;
			
			$key ++,
			$current = isset( $this->file_lexems[ $key ] ) ? $this->file_lexems[ $key ] : null
		){
			
			// Concatenates simple strings
			if($current && $current[0] === 'T_ENCAPSED_AND_WHITESPACE'){
				$next = isset($this->file_lexems[$key+1]) ? $this->file_lexems[$key+1] : null;
				if($next && $next[0] === 'T_ENCAPSED_AND_WHITESPACE'){
					$this->file_lexems[$key+1] = array(
						'T_ENCAPSED_AND_WHITESPACE',
						$current[1].$next[1],
						$current[2],
					);
					unset($this->file_lexems[$key]);
				}
			}
			
			// Concatenates 'a'.'b' and "a"."b" to 'ab'
			elseif($current && $current === '.'){
				
				$next = isset($this->file_lexems[$key+1]) ? $this->file_lexems[$key+1] : null;
				$prev = isset($this->file_lexems[$key-1]) ? $this->file_lexems[$key-1] : null;
				
				if(
					is_array($prev) && is_array($next) &&
					( $prev[0] == 'T_LNUMBER' || $prev[0] == 'T_CONSTANT_ENCAPSED_STRING' ) &&
					( $next[0] == 'T_LNUMBER' || $next[0] == 'T_CONSTANT_ENCAPSED_STRING' )
				){
					unset( $this->file_lexems[ $key - 1 ], $this->file_lexems[ $key ] );
					$prev[1] = $prev[1][0] === '"' ?  '\''.preg_replace("/'/", '\'', substr($prev[1], 1, -1))      : substr($prev[1], 0, -1);
					$next[1] = $next[1][0] === '"' ?       preg_replace("/'/", '\'', substr($next[1], 1, -1)).'\'' : substr($next[1], 1);
					$this->file_lexems[$key+1] = array(
						'T_CONSTANT_ENCAPSED_STRING',
						$prev[1].$next[1],
						$prev[2],
					);
				}
			}
		}
		$this->file_lexems = array_values($this->file_lexems);
	}
	
	/**
	 * Replaces ${'string'} to $variable
	 *
	 * @return void
	 */
	public function variables_replaceSophisticatedCall()
	{
		for(
			$key = 0,
			$current = null,
			$arr_size = count($this->file_lexems);
			
			$key < $arr_size;
			
			$key++,
			$current = isset($this->file_lexems[$key]) ? $this->file_lexems[$key] : null,
			$var_temp = null
		){
			
			if( $current === null )
				continue;
			
			// Replaces ${'string'} to $string
			if( $current === '$' ){
				
				$next  = $this->file_lexems[ $key + 1 ] ?: null;
				$next2 = $this->file_lexems[ $key + 2 ] ?: null;
				
				if( $next === '{' && is_array( $next2 ) && $next2[0] === 'T_CONSTANT_ENCAPSED_STRING' ){
					$this->file_lexems[ $key ] = array( 'T_VARIABLE', '$' . trim( $next2[1], '\'"' ), $next2[2] );
					unset( $this->file_lexems[ $key + 1 ], $this->file_lexems[ $key + 2 ], $this->file_lexems[ $key + 3 ] );
				}
				
			}
		}
	}
	
	/**
	 * Variable, arrays, constants control
	 *
	 * @return void
	 */
	public function variables_getAll()
	{
		
		// Clear arrays because they are not additive
		$this->arrays = array();
		
		for(
			$key = 0,
			$current = null,
			$arr_size = count($this->file_lexems);
			
			$key < $arr_size;
			
			$key++,
			$current = isset($this->file_lexems[$key]) ? $this->file_lexems[$key] : null,
			$var_temp = null
		){
			
			if($current && is_array($current) && $current[0] === 'T_VARIABLE'){
				
				$next1 = isset($this->file_lexems[$key+1]) ? $this->file_lexems[$key+1] : null;
				$next2 = isset($this->file_lexems[$key+2]) ? $this->file_lexems[$key+2] : null;
				$next3 = isset($this->file_lexems[$key+3]) ? $this->file_lexems[$key+3] : null;
				
				// Equation with concatenation.
				// $a .= 'value';
				if( isset( $next1[0], $this->variables[ $current[1] ] ) && $next1[0] === 'T_CONCAT_EQUAL' ){
					$variable_end = $this->lexem_getNext( $key, ';' ) - 1;
					if( $variable_end ){
						
						$var_temp = $this->lexem_getRange( $key + 2, $variable_end );
						
						$var_temp = count( $var_temp ) === 3 && $var_temp[0] === '"' && $var_temp[1][0] === 'T_ENCAPSED_AND_WHITESPACE' && $var_temp[2] === '"'
							? array( array( 'T_CONSTANT_ENCAPSED_STRING', '\'' . $var_temp[1][1] . '\'', $var_temp[1][2] ) )// Variable in a double quotes like $a .= "$b";
							: $var_temp; // // Variable in a single quotes like $a .= 'value';
						
						$this->variables[$current[1]] = array_merge($this->variables[$current[1]], $var_temp);
					}
					
					// Array. New element equation via
					// $arr[] = 'value';
				}elseif( $next1 === '[' && $next2 === ']' && $next3 === '=' ){
					$variable_end = $this->lexem_getNext( $key, ';' ) - 1;
					if( $variable_end ){
						$var_temp = $this->lexem_getRange( $key + 4, $variable_end );
						$var_temp = $var_temp[0];
						if( is_array( $var_temp ) && ( $var_temp[0] === 'T_CONSTANT_ENCAPSED_STRING' || $var_temp[0] === 'T_LNUBMER' ) ){
							$this->arrays[ $current[1] ][] = array( $var_temp[0], $var_temp[1], $var_temp[2] );
						}
					}
					
					// Array equation via 'Array' word
					// $arr = array();
				}elseif( $this->checkLexemsSequenceFromPosition( $key + 1, $this->sequences['array_equation_array']) ){
					$variable_end = $this->lexem_getNext($key, ';')-1;
					if($variable_end){
						$arr_lexemes = $this->lexem_getRange( $key + 4, $variable_end - 1 );
						foreach( $arr_lexemes as $arr_lexema ){
							if( is_array( $arr_lexema ) && ( $arr_lexema[0] === 'T_CONSTANT_ENCAPSED_STRING' || $arr_lexema[0] === 'T_LNUMBER' ) ){
								$this->arrays[ $current[1] ][] = array( $arr_lexema[0], $arr_lexema[1], $arr_lexema[2] );
							}
						}
					}
					
					// Array equation via '[]' operator
					// $arr = [];
				}elseif( $this->checkLexemsSequenceFromPosition( $key + 1, $this->sequences['array_equation_square_brackets']) ){
					$variable_end = $this->lexem_getNext($key, ';')-1;
					if($variable_end){
						$arr_lexemes = $this->lexem_getRange( $key + 3, $variable_end - 1 );
						foreach( $arr_lexemes as $arr_lexema ){
							if( is_array( $arr_lexema ) && ( $arr_lexema[0] === 'T_CONSTANT_ENCAPSED_STRING' || $arr_lexema[0] === 'T_LNUMBER' ) ){
								$this->arrays[ $current[1] ][] = array(
									'T_CONSTANT_ENCAPSED_STRING',
									$arr_lexema[1],
									$arr_lexema[2]
								);
							}
						}
					}
					
					// Simple equation
					// $a = 'value';
				}elseif( $next1 === '=' ){
					$variable_end = $this->lexem_getNext($key, ';')-1;
					if($variable_end){
						
						$var_temp = $this->lexem_getRange($key+2, $variable_end);
						
						$var_temp = count($var_temp) === 3 && $var_temp[0] === '"' &&  $var_temp[1][0] === 'T_ENCAPSED_AND_WHITESPACE' && $var_temp[2] === '"'
							? array( array( 'T_CONSTANT_ENCAPSED_STRING', '\'' . $var_temp[1][1] . '\'', $var_temp[1][2] ) )// Variable in a double quotes like $a = "$b";
							: $var_temp; // // Variable in a single quotes like $a = 'value';
						
						$this->variables[$current[1]] = $var_temp;
					}
				}
			}
			
			// Constants
			if( $this->checkLexemsSequenceFromPosition( $key, $this->sequences['define_constant'] ) ){
				if( $this->file_lexems[ $key +4 ][0] === 'T_CONSTANT_ENCAPSED_STRING' ){
					$this->constants[ trim( $this->file_lexems[ $key + 2 ][1], '\'"' ) ] = trim( $this->file_lexems[ $key + 4 ][1], '\'"' );
				}
			}
			
		}
	}
	
	/**
	 * @todo make it capable to compare variants of sequences. '(' to '(' or  '[',
	 *
	 * @param int   $position
	 * @param array $sequence Array of lexemes
	 *
	 * @return bool
	 */
	private function checkLexemsSequenceFromPosition( $position, $sequence ){
		
		foreach( $sequence as $offset => $lexema ){
			
			$position_to_check = $position + $offset;
			
			if( ! isset( $this->file_lexems[ $position_to_check ] ) ){
				return false;
			}
			
			// Both is arrays
			if( is_array( $lexema ) && is_array( $this->file_lexems[ $position_to_check ] ) ){
				
				// Compare first element
				if( $lexema[0] !== $this->file_lexems[ $position_to_check ][0] ){
					return false;
					
					// Compare second if provided
				}elseif( isset( $lexema[1] ) && $lexema[1] !== $this->file_lexems[ $position_to_check ][1] ){
					return false;
				}
				
				// At least one is not an array. Straight check
			}elseif( $lexema !== $this->file_lexems[ $position_to_check ] ){
				
				return false;
			}
		}
		
		return true;
	}
	
	/**
	 * Concatenate variable in $this->variables
     *
     * @return void
	 */
	public function variables_concatenate(){
		foreach($this->variables as $var_name => $var){
			for($i = count($var)-1; $i > 0; $i--){
				$curr = isset($var[$i])   ? $var[$i]   : null;
				$next = isset($var[$i-1]) ? $var[$i-1] : null;
				if(
                    in_array( $curr[0], $this->variables_types_to_concat, true ) &&
                    in_array( $next[0], $this->variables_types_to_concat, true )
                ){
					$this->_concatenate($this->variables[$var_name], $i, true);
				}
			}
		}
	}
	
	/**
	 * Replace variables with it's content
     *
     * @return void
	 */
	public function variables_replace()
	{
		$in_quotes = false;
		for(
			$key = 0,
			$current = null,
			$arr_size = count($this->file_lexems);
			
			$key < $arr_size;
			
			$key++,
			$current = isset($this->file_lexems[$key]) ? $this->file_lexems[$key] : null
		){
			
			if( $current === null ){
				continue;
			}
			
			if( $current === '"' ){
				$in_quotes = ! $in_quotes;
			}
			
			// Replace variable
			if( is_array( $current ) && $current[0] === 'T_VARIABLE' ){
				
				$next1 = isset( $this->file_lexems[ $key + 1 ] ) ? $this->file_lexems[ $key + 1 ] : null;
				$next2 = isset( $this->file_lexems[ $key + 2 ] ) ? $this->file_lexems[ $key + 2 ] : null;
				
				// Arrays
				if( isset( $this->arrays[ $current[1] ] ) ){
					
					$next = $this->lexem_getRange( $key + 1, $key + 4 );
					
					// Array element
					if( $next[0] === '[' && isset( $next[1][0] ) && $next[1][0] === 'T_LNUMBER' && in_array( $next[3], array( '.', '(', ';' ) ) ){
						
						if( isset( $this->arrays[ $current[1] ][ $next[1][1] ][1] ) ){
							
							if( $next[3] === '(' ){
								$this->file_lexems[ $key ] = array( 'T_STRING',                   substr( $this->arrays[ $current[1] ][ $next[1][1] ][1], 1, - 1 ), $current[2] );
							}elseif( $next[3] === '.' ){
								$this->file_lexems[ $key ]= array( 'T_CONSTANT_ENCAPSED_STRING', '\'' . $this->arrays[ $current[1] ][ $next[1][1] ][1] . '\'',                 $current[2] );
							}else{
								$this->file_lexems[ $key ]= array( $this->arrays[ $current[1] ][ $next[1][1] ][0], '\'' . $this->arrays[ $current[1] ][ $next[1][1] ][1] . '\'',                 $current[2] );
							}
							
							unset( $this->file_lexems[ $key + 1 ], $this->file_lexems[ $key + 2 ], $this->file_lexems[ $key + 3 ] );
							
						}
					}
					
					// Variables
				}elseif(
					isset( $this->variables[ $current[1] ] ) &&
					count( $this->variables[ $current[1] ] ) === 1 &&
					in_array( $this->variables[ $current[1] ][0][0], $this->variables_types_to_concat, true )
				){
					
					// Array or symbol from string replacement
					if( ( $next1 === '[' || $next1 === '{' ) && is_array( $next2 ) && $next2[0] === 'T_LNUMBER' ){
						
						if( isset( $this->variables[ $current[1] ][0][1][ $next2[1] ], $this->variables[ $current[1] ][0][1][ $next2[1] + 1 ] ) ){
							$this->file_lexems[ $key ][0] = 'T_CONSTANT_ENCAPSED_STRING';
							$this->file_lexems[ $key ][1] = '\'' . $this->variables[ $current[1] ][0][1][ $next2[1] + 1 ] . '\'';
							$this->file_lexems[ $key ][2] = $current[2];
							unset( $this->file_lexems[ $key + 1 ], $this->file_lexems[ $key + 2 ], $this->file_lexems[ $key + 3 ] );
							var_dump( "some2");
						}
						
						// @todo Learn to replace $$var to $var_value
//                    }elseif( is_array( $next ) && $next === 'T_VARIABLE' ){
						
						
						// Single variable replacement
					}else{
						
						// Variables function
						if( $next1 === '(' ){
							$this->file_lexems[ $key ][0] = 'T_STRING';
							$this->file_lexems[ $key ][1] = substr( $this->variables[ $current[1] ][0][1], 1, - 1 );
							$this->file_lexems[ $key ][2] = $current[2];
							
							// Variables in double/single quotes
						}elseif( ! in_array( $next1[0], $this->equals_lexems ) ){
							$this->file_lexems[ $key ][0] = ! $in_quotes ? 'T_CONSTANT_ENCAPSED_STRING' : 'T_ENCAPSED_AND_WHITESPACE';
							$this->file_lexems[ $key ][1] = ! $in_quotes ? $this->variables[ $current[1] ][0][1] : substr( $this->variables[ $current[1] ][0][1], 1, - 1 );
							$this->file_lexems[ $key ][2] = $current[2];
						}
					}
				}
				
				// Constant replacement
			}elseif( isset( $current[0] ) && $current[0] === 'T_STRING' && isset( $this->constants[ $current[1] ] )){
				$this->file_lexems[ $key ] = array( 'T_CONSTANT_ENCAPSED_STRING', '\'' . $this->constants[ $current[1] ] . '\'', $current[2] );
			}
		}
	}
	
	private function decodeData(){
		for(
			$key = 0,
			$current = null,
			$arr_size = count($this->file_lexems);
			
			$key < $arr_size;
			
			$key++,
			$current = isset($this->file_lexems[$key]) ? $this->file_lexems[$key] : null
		){
			
			// Decode for base64
			if( isset( $current[0] ) && $current[0] === 'T_STRING' ){
				
				$next = $this->lexem_getRange( $key + 1, $key + 2 );
				
				if( isset( $next[1] ) && $next[1][0] === 'T_CONSTANT_ENCAPSED_STRING' ){
					
					switch( $current[1] ){
						case 'base64_decode':
							$data = base64_decode( $next[1][1] );
							break;
						case 'urldecode':
							$data = urldecode( $next[1][1] );
							break;
						case 'rawurldecode':
							$data = rawurldecode( $next[1][1] );
							break;
						case 'gzinflate':
							$data = gzinflate( $next[1][1] );
							break;
						case 'str_rot13':
							$data = str_rot13( $next[1][1] );
							break;
						default:
							$data = false;
						
					}
					
					// Replacing function and data with it's result
					// decode_func('ENCODED_DATA') -> 'DECODED_DATA'
					if( $data ){
						$this->file_lexems[ $key ] = array( 'T_CONSTANT_ENCAPSED_STRING', '\'' . $data . '\'', $current[2] );
						// @todo Check for second parameter for gzinflate and base64_decode functions
						unset( $this->file_lexems[ $key + 1 ], $this->file_lexems[ $key + 2 ], $this->file_lexems[ $key + 3 ] );
					}
					
					if( $data ){
						
						// Decompress from GZ gzuncompress
						$prev = $this->lexem_getRange( $key - 2, $key - 1 );
						if( isset( $prev[0] ) && $prev[0][0] === 'T_STRING' && $prev[0][1] === 'gzuncompress' ){
							$data = gzuncompress( $data );
							if( $data ){
								
								unset( $this->file_lexems[ $key - 1  ], $this->file_lexems[ $key - 2 ], $this->file_lexems[ $key + 4 ] );
								$this->file_lexems[ $key ] = array( 'T_CONSTANT_ENCAPSED_STRING', '\'' . $data . '\'', $current[2] );
								$data = token_get_all( '<?php ' . $data );
								
								if( $data ){
									unset( $data[0] );
									$this->file_lexems = array_merge( $this->file_lexems, $data );
								}
								
							}
						}
						
					}
				}
			}
		}
	}
	
	public function variables_detectBad()
	{
		do{
			$bad_vars_count = count($this->variables_bad);
			
			foreach($this->variables as $var_name => $variable){
				
				foreach($variable as $var_part){
					
					if(
						$var_part[0] === 'T_VARIABLE' &&
						( in_array( $var_part[1], $this->variables_bad_default, true ) || isset( $this->variables_bad[ $var_part[1] ] ) )
					){
						$this->variables_bad[ $var_name ] = $variable;
						continue( 2 );
					}
					
				} unset($var_part);
				
			} unset($var_name, $variable);
			
		}while($bad_vars_count !== count($this->variables_bad));
	}
	
	// Brings all such constructs to include'path';
	public function includes_standardize()
	{
		for(
			$key = 0,
			$current = null,
			$arr_size = count($this->file_lexems);
			
			$key < $arr_size;
			
			$key++,
			$current = isset($this->file_lexems[$key]) ? $this->file_lexems[$key] : null
		){
			if( $current &&
			    ( strpos($current[0], 'INCLUDE') !== false || strpos($current[0], 'REQUIRE') !== false )
			){
				if($this->file_lexems[$key+1] === '('){
					$next_bracket = $this->lexem_getNext($key, ')');
					if($next_bracket !== false){
						unset( $this->file_lexems[ $key + 1 ] );
					}
					unset($this->file_lexems[$next_bracket]);
				}
				$this->file_lexems = array_values($this->file_lexems);
			}
		}
	}
	
	// Gets all of the include and require constructs. Checks for file extension and checks the path.
	public function includes_getAll()
	{
		for(
			$key = 0,
			$current = null,
			$arr_size = count($this->file_lexems);
			
			$key < $arr_size;
			
			$key++,
			$current = isset($this->file_lexems[$key]) ? $this->file_lexems[$key] : null,
			$prev_file_exists__key = null,
			$prev_file_exists      = null
		
		){
			if (
				! is_null( $current ) &&
				in_array(
					$current[0],
					array( 'T_INCLUDE', 'T_INCLUDE_ONCE', 'T_REQUIRE', 'T_REQUIRE_ONCE' )
				)
			){
				
				// Get previous "file_exists" function
				$prev_file_exists__start = $this->lexem_getPrev( $key, 'file_exists' );
				$prev_file_exists__end = $prev_file_exists__start
					? $this->lexem_getNext( $prev_file_exists__start, ')' )
					: null;
				$prev_file_exists = $prev_file_exists__start && $prev_file_exists__end
					? $this->lexem_getRange( $prev_file_exists__start, $prev_file_exists__end)
					: null;
				
				$include_end = $this->lexem_getNext($key, ';')-1;
				if($include_end){
					$include = $this->lexem_getRange($key+1, $include_end);
					if( $prev_file_exists ){
						$include['file_exists'] = $prev_file_exists;
					}
					$this->includes_processsAndSave($include, $key);
				}
				
			}
		}
	}
	
	public function includes_processsAndSave($include, $key)
	{
		// Check flags
		$unknown  = true;
		$good     = true;
		$status   = true;
		$not_url  = null;
		$path     = null;
		$exists   = null;
		$ext      = null;
		$ext_good = null;
		
		// Checking for bad variables in include
		foreach($include as $value){
			if($value[0] === 'T_VARIABLE' && (in_array($value[1], $this->variables_bad_default) || isset($this->variables_bad[$value[1]]))){
				$good = false;
				break;
			}
		} unset($value);
		
		// Checking for @ before include
		$error_free = $this->file_lexems[$key-1] === '@' ? false : true;
		
		// Include is a single string
		if(
			(count($include) == 1 && $include[0][0] === 'T_CONSTANT_ENCAPSED_STRING') or
			(count($include) == 3 && $include[0] === '(' && $include[1][0] === 'T_CONSTANT_ENCAPSED_STRING')
		){
			
			$path = count($include) == 3 ? substr($include[1][1], 1, -1) : substr($include[0][1], 1, -1); // Cutting quotes
			$not_url  = !filter_var($path, FILTER_VALIDATE_URL) ? true : false; // Checks if it is URL
			preg_match('/^(((\S:\\{1,2})|(\S:\/{1,2}))|\/)?.*/', $path, $matches);                         // Reconizing if path is absolute.
			$path     = empty($matches[1]) && $not_url ? $this->curr_dir.'/'.$path : $path;                // Make path absolute
			$exists   =
				$this->is_text &&
				! (
					isset( $include['file_exists'] ) &&
					$include['file_exists'][2][0] === 'T_CONSTANT_ENCAPSED_STRING' &&
					$include['file_exists'][2][0] === $path
				)
					? null
					: (realpath($path) ? true : false); // Checks for existence. null if checking text (not file).
			preg_match('/.*\.(\S*)$/', $path, $matches2);          // Reconizing extension.
			$ext      = isset($matches2[1]) ? $matches2[1] : '';
			$ext_good = in_array($ext, array('php', 'inc')) || is_dir($path) ? true : false;             // Good extension?
			
			$unknown  = false;
		}
		
		
		// Gather result in one flag
		$status = $good
			? (!$unknown
				? (!$not_url || !$ext_good
					? false
					: true)
				: null)
			: false;
		
		//$status = $good ? ($error_free ? ($unknown ? null : (!$not_url || !$exists || !$ext_good ? false : true)) : false) : false; // prev versison
		
		array_unshift($include, $this->file_lexems[$key]);
		
		$this->includes[] = array(
			'include'    => $include,
			'good'       => $good,
			'status'     => $status,
			'not_url'    => $not_url,
			'path'       => $path,
			'exists'     => $exists,
			'error_free' => $error_free,
			'ext'        => $ext,
			'ext_good'   => $ext_good,
			'string'     => $this->file_lexems[$key][2],
		);
	}
	
	public function sql_requests_getAll(){
		for(
			$key = 0, $current = null, $arr_size = count($this->file_lexems);
			$key < $arr_size;
			$key++
		){
			
			$current = $this->file_lexems[$key] ?: null;
			$sql_start = null;
			$sql_end = null;
			
			if( $current === null )
				continue;
			
			// WPDB
			if(
				$current[0] === 'T_VARIABLE' &&
				isset( $this->file_lexems[ $key + 3 ] ) &&
				$this->file_lexems[ $key + 1][0] === 'T_OBJECT_OPERATOR' &&
				$this->file_lexems[ $key + 2][0] === 'T_STRING' &&
				in_array( $this->file_lexems[$key+2][1], array( 'query', 'get_results' ) ) &&
				$this->file_lexems[$key+3][0] === '('
			){
				$sql_start = $key + 4;
				$sql_end = $this->lexem_getNext($key, ';')-1;
				
				// Mysqli
			}elseif(
				$current[0] === 'T_STRING' &&
				isset( $this->file_lexems[ $key + 2 ] ) &&
				in_array( $current[1], array( 'MYSQLI', 'mysqli' ) ) &&
				$this->file_lexems[ $key + 2 ][0] === 'T_STRING' &&
				in_array( $this->file_lexems[ $key + 2 ][1], array( 'query', 'send_query', 'multi_query' ) )
			){
				$sql_start = $key + 4;
				$sql_end   = $this->lexem_getNext( $key, ';' ) - 1;
				
				// PDO
			}elseif(
				$current[0] === 'T_STRING' &&
				isset( $this->file_lexems[ $key + 2 ] ) &&
				in_array( $current[1], array( 'PDO', 'pdo' ) ) &&
				$this->file_lexems[ $key + 2 ][0] === 'T_STRING' &&
				in_array( $this->file_lexems[ $key + 2 ][1], array( 'query', 'exec' ) )
			){
				$sql_start = $key + 4;
				$sql_end   = $this->lexem_getNext( $key, ';' ) - 1;
				
				// Mysql
			}elseif(
				$current[0] === 'T_STRING' &&
				in_array( $current[1], array( 'mysql_query', 'mysqli_query', 'mysqli_send_query', 'mysqli_multi_query' ) )
			){
				$sql_start = $key + 2;
				$sql_end   = $this->lexem_getNext( $key, ';' ) - 1;
			}
			
			
			if($sql_start && $sql_end){
				$sql = $this->lexem_getRange($sql_start, $sql_end);
				$this->sql_requests_processAndSave($sql, $key);
			}
		}
	}
	
	public function sql_requests_processAndSave($sql, $key ){
		
		$good = true; // SQL request is good by default
		
		// Checking for bad variables in sql
		foreach($sql as $value){
			if( $value[0] === 'T_VARIABLE' && ( in_array( $value[1], $this->variables_bad_default, true ) || isset( $this->variables_bad[ $value[1] ] ) ) ){
				$good = false;
				break;
			}
		}
		
		$status = ! empty( $good );
		
		$this->sql_requests[] = array(
			'sql'    => $sql,
			'status' => $status,
			'good'   => $good,
			'string' => $this->file_lexems[$key][2],
		);
		
	}
	
	public function make_verdict()
	{
		// Detecting bad functions
		foreach($this->file_lexems as $key => $lexem){
			if(is_array($lexem)){
				foreach( $this->bad_constructs as $severity => $set_of_functions){
					foreach($set_of_functions as $bad_function){
						if(
							$lexem[1] === $bad_function &&
							! (
								isset(
									$this->file_lexems[ $key - 1 ],
									$this->file_lexems[ $key - 1][0]
								) &&
								$this->file_lexems[ $key - 1][0] === 'T_OBJECT_OPERATOR'
							)
						){
							$this->verdict[$severity][$lexem[2]][] = $bad_function;
						}
					} unset($bad_function);
				} unset($severity, $set_of_functions);
			}
		}
		// Adding bad includes to $verdict['SEVERITY']['string_num'] = 'whole string with include'
		foreach($this->includes as $include){
			if($include['status'] === false){
				if($include['not_url'] === false or $include['ext_good'] === false)
					$this->verdict['CRITICAL'][$include['string']][] = substr($this->gather_lexems($include['include']), 0, 255);
				elseif($include['good'] === false)
					$this->verdict['SUSPICIOUS'][$include['string']][] = substr($this->gather_lexems($include['include']), 0, 255);
			}
		}
		// Adding bad sql to $verdict['SEVERITY']['string_num'] = 'whole string with sql'
		foreach($this->sql_requests as $sql){
			if($sql['status'] === false){
				$this->verdict['SUSPICIOUS'][$sql['string']][] = substr($this->gather_lexems($sql['sql']), 0, 255);
			}
		}
	}
	
	// Getting next setted lexem, Search for needle === if needle is set
	public function lexem_getNext($start, $needle = null)
	{
		for($i = 0, $key = $start+1; $i < 500; $i++, $key++){
			if(isset($this->file_lexems[$key])){
				$current = $this->file_lexems[$key];
				if($needle === null)
					return $key;
				elseif(!is_array($current) && $current === $needle || is_array($current) && $current[1] === $needle)
					return $key;
			}
		}
		return false;
	}
	
	/**
	 * Getting prev setted lexem, Search for needle === if needle is set
	 *
	 * @param int $start
	 * @param null $needle
	 *
	 * @return bool|int
	 */
	public function lexem_getPrev($start, $needle = null)
	{
		for($i = 0, $key = $start-1; $i < 100 && $key > 0; $i--, $key--){
			if(isset($this->file_lexems[$key])){
				$current = $this->file_lexems[$key];
				if(
                    $current === $needle ||
                    ( isset( $current[1] ) && $current[1] === $needle )
                ){
	                return $key;
                }
			}
		}
		return false;
	}
	
	// Getting prev set lexem, Search for needle === if needle is set
	public function lexem_getRange($start, $end)
	{
		return array_slice($this->file_lexems, $start, $end - $start + 1);
	}
	
	// Gathering file back
	public function gather_lexems($input = null)
	{
		$input = $input ?: $this->file_lexems;
		$out = '';
		foreach($input as $key => $lexem){
			$out .= is_array( $lexem ) ? $input[ $key ][1] : $input[ $key ];
		}
		
		return $out;
	}
	
	// MD5 current lexems
	// @todo compare size of input in the first place, then compare by value
	public function _stamp($input = null)
	{
		return md5($this->gather_lexems($input));
	}
	
	//* Concatenates anything
	public function _concatenate(&$lexems, $curr_index, $backwards = false, $type = 'T_ENCAPSED_AND_WHITESPACE'){
		$next_index = $curr_index + ($backwards ? (-1) : 1);
		$curr_val = $lexems[$curr_index][0] === 'T_CONSTANT_ENCAPSED_STRING' ? substr($lexems[$curr_index][1], 1, -1) : $lexems[$curr_index][1];
		$next_val = $lexems[$next_index][0] === 'T_CONSTANT_ENCAPSED_STRING' ? substr($lexems[$next_index][1], 1, -1) : $lexems[$next_index][1];
		$lexems[$next_index] = array(
			$lexems[$curr_index][0],
			'"' . ($backwards ? $next_val . $curr_val : $curr_val . $next_val) . '"',
			$lexems[$curr_index][2],
		);
		unset($lexems[$curr_index]);
	}
}
