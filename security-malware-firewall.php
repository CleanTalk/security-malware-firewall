<?php
/*
Plugin Name: Security by CleanTalk 
Plugin URI: https://wordpress.org/plugins/security-malware-firewall/ 
Description: The plugin temporary restricts attempts to login to WordPress backend. The restriction is rising for a few seconds if an account failed to login.  
Author: CleanTalk Security
Version: 2.6
Author URI: https://cleantalk.org
Text Domain: security-malware-firewall
Domain Path: /i18n
*/

// Prevent direct call
if ( ! defined( 'WPINC' ) ) {
	die('Not allowed!');
}

//
// To avoid issue with variable scope in activation hook.
// https://wordpress.org/support/topic/register_activation_hook-and-global-variables?replies=11
//

// Common params
define('SPBC_NAME',    'Security by CleanTalk');
define('SPBC_VERSION', '2.6');
define('SPBC_AGENT',   'wordpress-security-26');
define('SPBC_API_URL', 'https://api.cleantalk.org');        //Api URL
define('SPBC_PATH',             plugins_url('', __FILE__)); //HTTP path.   Plugin root folder without '/'.
define('SPBC_PLUGIN_DIR',       plugin_dir_path(__FILE__)); //System path. Plugin root folder with '/'.
define('SPBC_PLUGIN_BASE_NAME', plugin_basename(__FILE__)); //Plugin base name.

// Options names
define('SPBC_LOGIN_ATTEMPTS',   'spbc_login_attempts');   //Option name with login attempts.
define('SPBC_DATA',             'spbc_data');             //Option name with different plugin data.
define('SPBC_SETTINGS',         'spbc_settings');         //Option name with plugin settings.
define('SPBC_NETWORK_SETTINGS', 'spbc_network_settings'); //Option name with plugin network settings.
define('SPBC_DEBUG',            'spbc_debug');            //Option name with a debug data. Empty by default.

// Different params
define('SPBC_REMOTE_CALL_SLEEP',    10); //Minimum time between remote call
define('SPBC_LAST_ACTIONS_TO_VIEW', 20); //Nubmer of last actions to show in plugin settings page.

// Auth params
define('SPBC_MAX_FAILS',   '5');    // Limit of failed attempts before restrict access to backend. 
define('SPBC_CALC_PERIOD', '3600'); // Time interval to count failed attempts. 
define('SPBC_SLEEP_USUAL', '3');    // Give a delay before attempts to login.
define('SPBC_SLEEP_LONG',  '10');   // Give a delay before attempts to login.

// DataBase params
global $wpdb;
define('SPBC_LOG_TABLE',      'spbc_auth_logs');     //Table with logs.
define('SPBC_FIREWALL_DATA',  'spbc_firewall_data'); //Table with logs.
define('SPBC_FIREWALL_LOG',   'spbc_firewall_logs'); //Table with logs.
define('SPBC_SCAN_RESULTS',   'spbc_scan_results');  //Table with scanesults.
define('SPBC_SCAN_LINKS_LOG', 'spbc_scan_links_logs');
define('SPBC_SELECT_LIMIT',   5000);                 //Select limit for logs.
define('SPBC_WRITE_LIMIT',    10000);                //Write limit for firewall data.
define('SPBC_DB_PREFIX',      $wpdb->base_prefix);   // Getting original DB prefix (WPMS fix)

// Multisite
define('SPBC_WPMS', (is_multisite() ? true : false)); //WMPS is enabled

// Needed libraries.
require_once(SPBC_PLUGIN_DIR . 'lib/SpbcFireWall.php'); // FireWall ::SpbcFireWall()
require_once(SPBC_PLUGIN_DIR . 'lib/SpbcCron.php');     // Cron     ::SpbcCron()
require_once(SPBC_PLUGIN_DIR . 'lib/SpbcHelper.php');   // Helper   ::SpbcHelper
require_once(SPBC_PLUGIN_DIR . 'lib/SpbcState.php');    // State class

// Scanner libs
require_once(SPBC_PLUGIN_DIR . 'lib/SpbcScaner.php');       // Common analisys
require_once(SPBC_PLUGIN_DIR . 'lib/SpbcScannerLinks.php'); // Outbound links analisys
require_once(SPBC_PLUGIN_DIR . 'lib/SpbcScannerH.php');     // Heuristic analisys

// Misc libs
require_once(SPBC_PLUGIN_DIR . 'inc/spbc-tools.php');   // Different helper functions
require_once(SPBC_PLUGIN_DIR . 'inc/spbc-scanner.php'); 

// ArrayObject with settings and other global varables
global $spbc;
$spbc = new SpbcState('spbc', array('settings', 'data', 'installing'), SPBC_WPMS);

// Setting SPBC statuses
if(SPBC_WPMS)
	$spbc->allow_custom_key = !empty($spbc->network_settings['allow_custom_key']) ? true : false;

// Different
if(is_main_site() || !empty($spbc->allow_custom_key)){
	
	//Account params
	$spbc->key_is_ok    = !empty($spbc->data['key_is_ok'])       ? 1                              : 0;
	$spbc->user_token   = !empty($spbc->data['user_token'])      ? $spbc->data['user_token']      : '';
	$spbc->service_id   = !empty($spbc->data['service_id'])      ? $spbc->data['service_id']      : 0;
	$spbc->moderate     = !empty($spbc->data['moderate'])        ? $spbc->data['moderate']        : 0;
	$spbc->auto_update  =  isset($spbc->data['auto_update_app']) ? $spbc->data['auto_update_app'] : 0;

	// Notices flags
	$spbc->show_notice        = !empty($spbc->data['notice_show'])         ? 1 : 0;
	$spbc->renew              = !empty($spbc->data['notice_renew'])        ? 1 : 0;
	$spbc->trial              = !empty($spbc->data['notice_trial'])        ? 1 : 0;
	$spbc->notice_auto_update = !empty($spbc->data['notice_auto_update'])  ? 1 : 0;
	$spbc->were_updated       = !empty($spbc->data['notice_were_updated']) ? 1 : 0;
	
}else{
	//Account params
	$spbc->key_is_ok    = (!empty($spbc->network_settings['key_is_ok'])  ? 1 : 0);
	$spbc->user_token   = (!empty($spbc->network_settings['user_token']) ? $spbc->network_settings['user_token'] : '');
	$spbc->service_id   = (!empty($spbc->network_settings['service_id']) ? $spbc->network_settings['service_id'] : 0);
	$spbc->moderate     = (!empty($spbc->network_settings['moderate'])   ? $spbc->network_settings['moderate']   : 0);
	
	// Notices flags
	$spbc->show_notice  = 0;
	$spbc->renew        = 0;
	$spbc->trial        = 0;
	$spbc->were_updated = 0;
}

// Only for lcoal/main site
if(is_main_site()){
	// Scanner
	$spbc->scaner_enabled = true;
	$spbc->scaner_status  = $spbc->moderate                        ? true : false;
	$spbc->scaner_warning = !empty($spbc->data['scaner_warning'])  ? true : false;
	if(!ini_get('allow_url_fopen'))
		$spbc->data['errors']['allow_url_fopen'] = true;
	
	// Traffic Control
	$spbc->tc_enabled      = !empty($spbc->settings['traffic_control_enabled']) ? true : false;
	$spbc->tc_status       = $spbc->tc_enabled && $spbc->moderate               ? true : false;
}else{
	$spbc->scaner_enabled  = false;
	$spbc->tc_enabled      = false;
	$spbc->tc_status       = false;
}

// Logged hooks
register_activation_hook( __FILE__,   'spbc_activation' );
register_deactivation_hook( __FILE__, 'spbc_deactivation' );

// Auth hooks
add_filter('authenticate',   'spbc_authenticate', 99, 3);     // Hooks for authentificate
add_action('wp_logout',      'spbc_wp_logout');               // Hooks for authentificate
add_action('login_footer',   'spbc_login_form_notification'); // Hook for registration form notification
add_action('plugins_loaded', 'spbc_plugin_loaded');           // Main hook

// Self cron
global $spbc_cron; // Letting know functions that they are running under spbc_cron
$spbc_cron = new SpbcCron();
$spbc_cron->checkTasks();
if(!empty($spbc_cron->tasks_to_run)){
	$spbc_cron->runTasks();
}
unset($spbc_cron);

if (is_admin() || is_network_admin()) {
	
    require_once(SPBC_PLUGIN_DIR. 'inc/spbc-admin.php');
	require_once(SPBC_PLUGIN_DIR . 'templates/spbc_settings_main.php'); // Templates for settings pgae

	add_action('admin_init',            'spbc_activation_redirect', 1); // Redirect after activation
    add_action('admin_init',            'spbc_admin_init', 1, 1);       // Main admin hook
    add_action('admin_menu',            'spbc_admin_add_page');         // Admin pages
	add_action('network_admin_menu',    'spbc_admin_add_page');         // Network admin pages
	add_action('admin_enqueue_scripts', 'spbc_enqueue_scripts');        // Scripts
    
	if(!defined( 'DOING_AJAX' )){
		add_action('admin_notices',         'spbc_admin_notice_message');
		add_action('network_admin_notices', 'spbc_admin_notice_message');
	}
	
	// Customize row with the plugin on plugins list page.
    if((isset($pagenow) && $pagenow == 'plugins.php') || @strpos($_SERVER['REQUEST_URI'],'plugins.php')!==false) {
		add_filter('plugin_action_links_' . SPBC_PLUGIN_BASE_NAME,               'spbc_plugin_action_links', 10, 2);
		add_filter('network_admin_plugin_action_links_' . SPBC_PLUGIN_BASE_NAME, 'spbc_plugin_action_links', 10, 2);
		add_filter('plugin_row_meta',                                            'spbc_plugin_links_meta',   10, 2);
    }
	
}

if(!is_admin() && !defined('DOING_AJAX')){
	
	//First start
	if($spbc->settings && $spbc->key_is_ok){
				
		//* Remote calls //REMOTE_ADDR!!!
		
		
		if(isset($_GET['spbc_remote_call_token'], $_GET['spbc_remote_call_action'], $_GET['plugin_name']) && in_array($_GET['plugin_name'], array('security','spbc'))){
			
			// Comparsing with cleantalk's IP
			$spbc_remote_ip = SpbcHelper::get_real_ip($spbc->data['cdn']);
			
			if($spbc_remote_ip !== false){
				
				$resolved = gethostbyaddr($spbc_remote_ip);
				
				if($resolved !== false){
										
					if(preg_match('/cleantalk\.org$/', $resolved) === 1 || $resolved === 'back'){
						
						if(!isset($spbc->data['last_remote_call']) || (isset($spbc->data['last_remote_call']) && time() - $spbc->data['last_remote_call'] > SPBC_REMOTE_CALL_SLEEP)){
							
							$spbc->data['last_remote_call'] = time();
							$spbc->save('data');
							
							if($_GET['spbc_remote_call_token'] == md5($spbc->settings['spbc_key'])){
								
								// Update FireWall data
								if($_GET['spbc_remote_call_action'] == 'update_security_firewall'){
									$result = spbc_security_firewall_update($spbc->settings['spbc_key']);
									die(empty($result['error']) ? 'OK' : 'FAIL '.json_encode(array('error' => $result['error_string'])));
									
								// Close renew banner
								}elseif($_GET['spbc_remote_call_action'] == 'close_renew_banner'){
									$spbc->data['notice_show'] = 0;
									$spbc->save('data');
									// Updating cron task
									SpbcCron::updateTask('access_key_notices', 'spbc_access_key_notices', 86400);
									die('OK');
								
								// Drop FireWall data
								}elseif($_GET['spbc_remote_call_action'] == 'drop_security_firewall'){
									$result = spbc_security_firewall_drop();
									die(empty($result['error']) ? 'OK' : 'FAIL '.json_encode(array('error' => $result['error_string'])));
								
								// Update plugin
								}elseif($_GET['spbc_remote_call_action'] == 'update_plugin'){
									add_action('template_redirect', 'spbc_update', 1);
								}else
									die('FAIL '.json_encode(array('error' => 'UNKNOWN_ACTION')));
							}else
								die('FAIL '.json_encode(array('error' => 'WRONG_TOKEN')));
						}else
							die('FAIL '.json_encode(array('error' => 'TOO_MANY_ATTEMPTS')));
					}else
						die('FAIL '.json_encode(array('error' => 'WRONG_IP')));
				}else
					die('FAIL '.json_encode(array('error' => 'COULDNT_RESOLVE_IP')));
			}else
				die('FAIL '.json_encode(array('error' => 'COULDNT_RECONIZE_IP')));
			
		}
		
		// FireWall block
		$traffic_control       = !empty($spbc->settings['traffic_control_enabled'])          ? true : false;
		$traffic_control_limit = !empty($spbc->settings['traffic_control_autoblock_amount']) ? $spbc->settings['traffic_control_autoblock_amount'] : 1000;
		$firewall              = new SpbcFireWall();
		$ip                    = $firewall->get_real_ip($spbc->data['cdn'], $spbc->data['private_networks']);
		
		$is_firewall_check = true;
		if(!$traffic_control){
			foreach($ip as $spbc_cur_ip){
				// Passing via cookie
				if(isset($_COOKIE['spbc_firewall_pass_key']) && $_COOKIE['spbc_firewall_pass_key'] == md5($spbc_cur_ip.$spbc->settings['spbc_key']))
					$is_firewall_check = false;
				else
					$is_firewall_check = true;
			}
		}
		
		// Skip the check
		if(!empty($_GET['access'])){
			
			$apbct_settings = get_option('cleantalk_settings');
			$apbct_key = !empty($apbct_settings['apikey']) ? $apbct_settings['apikey'] : false;
			
			if(($_GET['access'] === $spbc->settings['spbc_key'] || ($apbct_key !== false && $_GET['access'] === $apbct_key))){
				$is_firewall_check = false;
				setcookie ('spbc_firewall_pass_key', md5($_SERVER['REMOTE_ADDR'].$spbc->settings['spbc_key']), time()+1200, '/');
				setcookie ('ct_sfw_pass_key',        md5($_SERVER['REMOTE_ADDR'].$apbct_key),                  time()+1200, '/');
			}
			unset($apbct_settings, $apbct_key);
		}
		
		if($is_firewall_check){
			
			$firewall->check_ip($traffic_control, $traffic_control_limit);
						
			// Blacklisted in DB
			if(strpos($firewall->result, 'DENY') !== false){
				SpbcFireWall::firewall_update_logs($firewall->blocked_ip, false, $firewall->result);
				$firewall->spbc_die($spbc->service_id);
			// Whitelisted in DB
			}elseif(strpos($firewall->result, 'PASS') !== false){ 
				SpbcFireWall::firewall_update_logs($firewall->passed_ip, true, $firewall->result);
				if(!empty($spbc->settings['set_cookies'])){
					setcookie ('spbc_firewall_pass_key', md5($firewall->passed_ip.$spbc->settings['spbc_key']), 300, '/');
				}
			}
		}
		
		unset($is_firewall_check, $firewall, $ip, $spbc_cur_ip);
	}
}

//
// A code during plugin activation.
//
function spbc_activation() {
	
    global $wpdb;
	
	$spbc_auth_logs_table      = SPBC_DB_PREFIX . SPBC_LOG_TABLE;
	$spbc_firewall_data_table  = SPBC_DB_PREFIX . SPBC_FIREWALL_DATA;
	$spbc_firewall_logs_table  = SPBC_DB_PREFIX . SPBC_FIREWALL_LOG;
	$spbc_scan_results_table   = SPBC_DB_PREFIX . SPBC_SCAN_RESULTS;
	$spbc_scan_links_log_table = SPBC_DB_PREFIX . SPBC_SCAN_LINKS_LOG;
	
    $sql = "CREATE TABLE IF NOT EXISTS $spbc_auth_logs_table (
		`id` int(11) NOT NULL AUTO_INCREMENT,
		`datetime` datetime NOT NULL,
		`user_login` varchar(60) NOT NULL,
		`event` varchar(32) NOT NULL,
		`page` VARCHAR(500) NULL,
		`page_time` VARCHAR(10) NULL,
		`blog_id` int(11) NOT NULL,
		`auth_ip` int(10) unsigned DEFAULT NULL,
		`role` varchar(64) DEFAULT NULL,
		PRIMARY KEY (`id`),
		KEY `datetime` (`datetime`,`event`)
		) ENGINE=MyISAM  DEFAULT CHARSET=latin1 AUTO_INCREMENT=1;";
    $wpdb->query($sql);
    
	$sql = "CREATE TABLE IF NOT EXISTS $spbc_firewall_data_table (
		`spbc_network` int(11) unsigned NOT NULL,
		`spbc_mask` int(11) unsigned NOT NULL,
		`status` TINYINT(1) NULL,
		INDEX (`spbc_network` , `spbc_mask`)
		) ENGINE = MYISAM ;";
	$wpdb->query($sql);
				
	$sql = "CREATE TABLE IF NOT EXISTS $spbc_firewall_logs_table (
		`entry_id` VARCHAR(40) NOT NULL,
		`ip_entry` VARCHAR(15) NULL, 
		`allowed_entry` INT NOT NULL, 
		`blocked_entry` INT NOT NULL,
		`status` ENUM('PASS','PASS_BY_WHITELIST','DENY','DENY_BY_NETWORK','DENY_BY_DOS') NULL,
		`page_url` VARCHAR(4096) NULL,
		`request_method` VARCHAR(5) NULL,
		`x_forwarded_for` VARCHAR(15) NULL,
		`http_user_agent` VARCHAR(300) NULL,
		`entry_timestamp` INT NOT NULL , 
		PRIMARY KEY (`entry_id`)) 
		ENGINE = MYISAM;";
	$wpdb->query($sql);	
	
	$sql = "CREATE TABLE IF NOT EXISTS $spbc_scan_results_table (
		`path` VARCHAR(1024) NOT NULL,
		`size` INT(10) NOT NULL,
		`perms` INT(4) NOT NULL,
		`mtime` INT(11) NOT NULL,
		`source` ENUM('CORE', 'PLUGIN') NOT NULL DEFAULT 'CORE',
		`checked` ENUM('NO','YES') NOT NULL DEFAULT 'NO',
		`status` ENUM('UNKNOWN','OK','APROVED','COMPROMISED','INFECTED') NOT NULL DEFAULT 'UNKNOWN',
		`severity` ENUM('CRITICAL', 'DANGER', 'SUSPICIOUS', 'NONE') NULL DEFAULT NULL,
		`weak_spots` VARCHAR(1024) NULL DEFAULT NULL,
		`difference` VARCHAR(1024) NULL DEFAULT NULL,
		`last_sent` INT(11) NOT NULL,
		`fast_hash` VARCHAR(32) NULL DEFAULT NULL,
		`full_hash` VARCHAR(32) NULL DEFAULT NULL,
		`real_full_hash` VARCHAR(32) NULL DEFAULT NULL,
		UNIQUE (`fast_hash`)
	) ENGINE = MYISAM;";
	$wpdb->query($sql);
	
	$sql = "CREATE TABLE IF NOT EXISTS $spbc_scan_links_log_table (
		`log_id` int(11) NOT NULL AUTO_INCREMENT,
		`user_id` int(11) unsigned DEFAULT NULL,
		`service_id` int(11) unsigned DEFAULT NULL,
		`submited` datetime NOT NULL,
		`total_links_found` INT NOT NULL,
		`links_list` TEXT DEFAULT NULL,
		PRIMARY KEY (`log_id`)
		) ENGINE = MYISAM DEFAULT CHARSET=latin1 AUTO_INCREMENT=1;";
	$wpdb->query($sql);  

	//Cron jobs	
	SpbcCron::addTask('send_logs',            'spbc_send_logs',                3600,  time()+1800);
	SpbcCron::addTask('send_report',          'spbc_send_daily_report',        86400, time()+43200);
	SpbcCron::addTask('firewall_update',      'spbc_security_firewall_update', 86400, time()+43200);
	SpbcCron::addTask('send_firewall_logs',   'spbc_send_firewall_logs',       3600,  time()+1800);
	SpbcCron::addTask('access_key_notices',   'spbc_access_key_notices',       3600,  time()+3500);
	SpbcCron::addTask('perform_scan_wrapper', 'spbc_perform_scan_wrapper',     86400, time()+86400);
	
	add_option('spbc_activation_redirect', (is_network_admin() ? 'settings.php?page=spbc' : 'options-general.php?page=spbc'));
}

//
// Function for redirect to settings
//
function spbc_activation_redirect(){
	
	$settings_rediect = get_option('spbc_activation_redirect', false);
	
	if($settings_rediect && !isset($_GET['activate-multi'])){
		delete_option('spbc_activation_redirect');
		wp_redirect($settings_rediect);
	}
}

//
// A code during plugin deactivation.
//
function spbc_deactivation(){
	
	global $spbc;
	
	unregister_setting(SPBC_SETTINGS, SPBC_SETTINGS);
	
	//Complete deactivation		
	if(!empty($spbc->settings['complete_deactivation'])){

		//For WPMS
		if(SPBC_WPMS){
			//Deleting network options from wp_sitemeta.
			delete_site_option(SPBC_NETWORK_SETTINGS);
			//Get all sites and delete all option from it.
			$sites =  get_sites();
			foreach($sites as $site){
				delete_blog_option($site -> blog_id, SPBC_SETTINGS);
				delete_blog_option($site -> blog_id, SPBC_DATA);
				delete_blog_option($site -> blog_id, SPBC_LOGIN_ATTEMPTS);
			} unset($site, $sites);	
		//For non WPMS
		}else{
			delete_option(SPBC_NETWORK_SETTINGS);
			delete_option(SPBC_SETTINGS);
			delete_option(SPBC_DATA);
			delete_option(SPBC_DEBUG);
			delete_option(SPBC_LOGIN_ATTEMPTS);
			delete_option('spbc_cron'); // Deleting cron entries
		}
				
		//Deleting all tables
		global $wpdb;		
		$wpdb->query('DROP TABLE '. SPBC_DB_PREFIX . SPBC_LOG_TABLE);
		$wpdb->query('DROP TABLE '. SPBC_DB_PREFIX . SPBC_FIREWALL_DATA);
		$wpdb->query('DROP TABLE '. SPBC_DB_PREFIX . SPBC_FIREWALL_LOG);
		$wpdb->query('DROP TABLE '. SPBC_DB_PREFIX . SPBC_SCAN_RESULTS);
		$wpdb->query('DROP TABLE '. SPBC_DB_PREFIX . SPBC_SCAN_LINKS_LOG);
		
	}
}

//
// Misc functions to test the plugin.
//
function spbc_plugin_loaded() {
		
	if(is_admin() || is_network_admin()){
		$dir = plugin_basename( dirname( __FILE__ ) ) . '/i18n';
		$loaded = load_plugin_textdomain('security-malware-firewall', false, $dir);
	}
	
	// For testing
    if (isset($_GET['spbc_test_daily_report']))
        spbc_send_daily_report(true); 
}

/*
 * Initiate session
*/
function spbc_init_session() {

    $session_id = session_id(); 
    if(empty($session_id) && !headers_sent()) {
        $result = @session_start();
        if(!$result){
            session_regenerate_id(true);
            @session_start(); 
        }
    }
	
    return;
}

//
// Adding notification to registration form
//
function spbc_login_form_notification(){
	
	global $pagenow, $spbc;
	
	if($pagenow == 'wp-login.php' && empty($_GET['action'])){ //Return if it's not a registration page.
		
		$show_notification = (!empty($spbc->settings['show_link_in_login_form']) ? true : false);
		
		if($show_notification)
			echo "<div style='position: absolute; bottom: 20px; right: 20px;'>"
				."<p style='text-align: right;'>"
					.__('Brute Force Protection by', 'security-malware-firewall')."&nbsp;<a rel='nofollow' href='https://wordpress.org/plugins/security-malware-firewall/' target='_blank'>"
						."<img style='vertical-align: bottom;' src='".SPBC_PATH."/images/logo_small.png'></a>"
						."<a rel='nofollow' href='https://wordpress.org/plugins/security-malware-firewall/' target='_blank'>".__('CleanTalk Security', 'security-malware-firewall')."</a>"
				.".</p>"
				."<p style='text-align: right;'>".__('All attempts are logged.', 'security-malware-firewall')."</p>
			</div>";
	}
	return null;
}

//
// Test an attempt to get authed in WordPress backend.
//
function spbc_authenticate($user, $username, $password){
    
	global $spbc;
	
	if(is_wp_error($user)){

		$err_codes = $user->get_error_codes();
		// Passwords brute force.
		if (in_array( 'incorrect_password', $err_codes )) {
			$sleep_timeout = SPBC_SLEEP_USUAL;
            $spbc_login_attempts = get_option( SPBC_LOGIN_ATTEMPTS );
            if (is_array($spbc_login_attempts)) {
                
                if (isset($spbc_login_attempts[$username])) {
                    if ($spbc_login_attempts[$username]['attempts'] >= SPBC_MAX_FAILS) {
                        spbc_add_issue($username, $password, $spbc_login_attempts);
						$sleep_timeout = SPBC_SLEEP_LONG;
                    } else {
                        spbc_add_issue($username, $password, $spbc_login_attempts);
                    }
                } else {
                    spbc_add_issue($username, $password, $spbc_login_attempts, true);
                }
            } else {
                spbc_add_issue($username, $password, $spbc_login_attempts, true);
            }
			sleep ($sleep_timeout);
			$user->add( 'spbc_bf_timeout', sprintf(__('<br />Authorization attempt has been banned for %d seconds. %s.' ), 
				$sleep_timeout,
				SPBC_NAME
			));
        }
        
		// Usernames brute force.
		if (in_array( 'invalid_username', $err_codes )) {
			$user = spbc_log_issue_common(
				$username,
				'invalid_username',
				SPBC_SLEEP_USUAL,
				$user
			);
        }
   		
		// Emails brute force.
		if (in_array( 'invalid_email', $err_codes )) {
			$user = spbc_log_issue_common(
				$username,
				'invalid_email',
				SPBC_SLEEP_USUAL,
				$user
			);
        }
    }
    
    // The user is logged in.
	if (isset($user->ID) && $user->ID > 0) {
		$roles = null;
		if (is_array($user->roles)) {
			$roles = $user->roles[0]; // Takes only first role.
		}
        spbc_auth_log(array(
            'username' => $username,
			'event' => 'login',
			'roles' => $roles
        ));
		
		// Sends logs to get notify about superuser login.
		$result = spbc_send_logs();
		if(empty($result['error'])){
			SpbcHelper::deleteError('send_logs');
			$spbc->data['logs_last_sent'] = current_time('timestamp');
			$spbc->data['last_sent_events_count'] = $result;
			$spbc->save('data');
		}else{
			SpbcHelper::addError('send_logs', $result);
		}
	}

    return $user;
}

//
// Logs an issue.
//
function spbc_log_issue_common($username, $event, $sleep_timeout, $user = null) {
	spbc_auth_log(array(
		'username' => $username,
		'event' => $event, 
	));
	sleep ($sleep_timeout);

    if(is_wp_error($user)) {
		$user->add( 'spbc_bf_timeout', sprintf(__('<br />Authorization attempt has been banned for %d seconds to prevent unauthorized access. %s.' ), 
			$sleep_timeout,
			SPBC_NAME
		) );
	}	
	return $user;
}

// Adds a record to failed logins.
function spbc_add_issue($username, $password, $attempts, $new_issue = false) {
    
    // Reset the data to avaoid PHP issues.
    if (!isset($attempts) || !count($attempts)) {
        $attempts = array();
    }
    
    if (isset($attempts[$username]['first_issue']) && time() - $attempts[$username]['first_issue'] > SPBC_CALC_PERIOD) {
        $new_issue = true;
        unset($attempts[$username]);
    }

    $update_option = false;
    if ($new_issue) {
        $attempts[$username]['attempts'] = 1;
        $attempts[$username]['first_issue'] = time();
        $attempts[$username]['passwords'][] = md5($password);
        $update_option = true;
    } else {

        // Increase attempts only if new password failed.
        if (!in_array(md5($password), $attempts[$username]['passwords'])) {
            $attempts[$username]['attempts']++;
            $attempts[$username]['passwords'][] = md5($password);
            $update_option = true;
        }
    }
    
    if ($update_option) {
        update_option(SPBC_LOGIN_ATTEMPTS , $attempts);
        spbc_auth_log(array(
            'username' => $username,
            'event' => 'auth_failed'
        ));
    }

    return null;
}

//
// The function logs any attempt to log in the WordPress backend.
//
function spbc_auth_log($params = null) {
    global $wpdb;
    
    $params_default = array(
        'username'  => null,
        'event'     => null,
		'page'      => null,
		'page_time' => null,
		'roles'     => null,
		'blog_id'   => (SPBC_WPMS ? get_current_blog_id() : null)
    );
    $params = array_merge($params_default, $params);

    if (function_exists( 'filter_var' )) {
        // The plugin doesn't use any IP from HTTP* headers, because these types of IPs can be spoofed.
		$auth_ip = array_key_exists('REMOTE_ADDR', $_SERVER) ? filter_var($_SERVER['REMOTE_ADDR'], FILTER_VALIDATE_IP, FILTER_FLAG_IPV4) : '127.0.0.1';
		if($auth_ip == $_SERVER['SERVER_ADDR'] || $auth_ip == '127.0.0.1'){ //Server with cache software
			if(isset($_SERVER['HTTP_X_FORWARDED_FOR'])){
				$ips = explode(',', trim($_SERVER['HTTP_X_FORWARDED_FOR']));
				$auth_ip = filter_var(end($ips), FILTER_VALIDATE_IP, FILTER_FLAG_IPV4);
			}
		}
    }

    $spbc_auth_logs_table = SPBC_DB_PREFIX . SPBC_LOG_TABLE;
	
    // To fix issue with NULL values for not NULL field.
    $blog_id = isset($params['blog_id']) && $params['blog_id'] !== null ? $params['blog_id'] : 1;

    $values = array(
        'datetime'   => date('Y-m-d H:i:s'),
        'user_login' => $params['username'],
        'event'      => $params['event'],
        'auth_ip'    => isset($auth_ip) ? sprintf('%u', ip2long($auth_ip)) : null,
		'page'       => $params['page'],
		'page_time'  => $params['page_time'],
		'blog_id'    => $blog_id, 
		'role'       => $params['roles'] 
    );
    $result = $wpdb->insert(
        $spbc_auth_logs_table,
        $values
    );
	
	$inserted_id = $wpdb->insert_id;
	
    return $inserted_id;
}

//
// Logs a logout event
//
function spbc_wp_logout() {
    $user = wp_get_current_user();

    // The user is logged out.
    if (isset($user->ID) && $user->ID > 0) {
		$roles = null;
		if (is_array($user->roles)) {
			$roles = $user->roles[0]; // Takes only first role.
		}
        spbc_auth_log(array(
            'username' => $user->get('user_login'), 
			'event'    => 'logout',
			'roles'    => $roles
        ));
    }

    return null;
}

//
// Sorts some data.
//
function spbc_usort_desc($a, $b) {
    return $b->datetime_ts - $a->datetime_ts;
};

//
// Function to get the countries by IPs list.
//
function spbc_get_countries_by_ips($ips_data = '') {
    global $api_url;

    $ips_c = array();
    
    if ($ips_data === '')
        return $ips_c;
    
	$result = SpbcHelper::ipInfo($ips_data);
	
	if (empty($result['error'])) {
		
		foreach ($result as $ip_dec => $v2) {
			
			if (isset($v2['country_code']))
				$ips_c[$ip_dec]['country_code'] = $v2['country_code']; 
			
			if (isset($v2['country_name']))
				$ips_c[$ip_dec]['country_name'] = $v2['country_name']; 
			
		}
	}

    return $ips_c;
}

//
//	Sendings Security FireWall logs
//
function spbc_send_firewall_logs($api_key = false){
	
    global $spbc;
		
	$api_key = $api_key !== false ? $api_key : $spbc->settings['spbc_key'];
	
	if(!empty($api_key)){
	
		$result = SpbcFireWall::send_logs($api_key);
				
		if(empty($result['error'])){
			$spbc->data['last_firewall_send'] = current_time('timestamp');
			$spbc->data['last_firewall_send_count'] = $result;
			$spbc->save('data');
			return $result;
		}else{
			return $result;	
		}
	}
	
	return array(
		'error' => true,
		'error_string' => 'FW_DISABLED'
	);	
}

//
//	Updating Security FireWall data
//
function spbc_security_firewall_update($api_key = false){
	
	global $spbc;
		
	$api_key = $api_key !== false ? $api_key : $spbc->settings['spbc_key'];

	if(!empty($api_key)){
		
		$result = SpbcFireWall::firewall_update($api_key);
		
		if(empty($result['error'])){
			$spbc->data['last_firewall_updated'] = current_time('timestamp');
			$spbc->data['firewall_entries'] = $result;
			$spbc->save('data');
			return $result;
		}else{
			return $result;	
		}
	}
	
	return array(
		'error' => true,
		'error_string' => 'FW_DISABLED'
	);
}

//
//	Drop Security FireWall data
//
function spbc_security_firewall_drop(){
	
	global $wpdb;
	
	$result = $wpdb->query('DELETE FROM `'.$wpdb->base_prefix.'spbc_firewall_data`;');
	
	if($result !== false){
		return true;
	}else{
		return array(
			'error' => true,
			'error_string' => 'DELETE_ERROR'
		);	
	}
}

function spbc_update(){
	
	//Upgrade params
	$plugin      = 'security-malware-firewall\security-malware-firewall.php';
	$plugin_slug = 'security-malware-firewall';
	$title 	     = __('Update Plugin');
	$nonce 	     = 'upgrade-plugin_' . $plugin;
	$url 	     = 'update.php?action=upgrade-plugin&plugin=' . urlencode( $plugin );
	
	$prev_version = SPBC_VERSION;
	
	require_once( ABSPATH . 'wp-admin/includes/plugin.php' );
	require_once( ABSPATH . 'wp-admin/includes/class-wp-upgrader.php' );
	require_once( ABSPATH . 'wp-admin/includes/file.php' );
	require_once( ABSPATH . 'wp-admin/includes/misc.php' );
	
	require_once( SPBC_PLUGIN_DIR . 'lib/SpbcUpgrader.php' );
	require_once( SPBC_PLUGIN_DIR . 'lib/SpbcUpgraderSkin.php' );
	
	$upgrader = new SpbcUpgrader( new SpbcUpgraderSkin( compact('title', 'nonce', 'url', 'plugin') ) );
    $upgrader->upgrade($plugin);
		
	if($upgrader->spbc_result === 'OK'){
				
		// $result = activate_plugins( $plugin );
		
		if(is_wp_error($result))
			die('FAIL '. json_encode(array('error' => 'COULD_NOT_ACTIVATE', 'wp_error' => $result->get_error_message())));
		if($result === false)
			die('FAIL '. json_encode(array('error' => 'COULD_NOT_ACTIVATE')));
				
		$urlHeaders = get_headers(get_option('siteurl'));
		
		if( strpos($urlHeaders[0], '200') === false ){
						
			$response = array(
				'error' => 'BAD_HTTP_CODE',
				'http_code' => $urlHeaders[0],
				'output' => substr(file_get_contents(get_option('siteurl')), 0, 4000),
			);
			
			// Rollback
			$rollback = new SpbcUpgrader( new SpbcUpgraderSkin( compact('title', 'nonce', 'url', 'plugin_slug', 'prev_version') ) );
			$rollback->rollback($plugin);
			
			$response['rollback_result'] = $rollback->spbc_result;
			
			die('FAIL '.json_encode($response));
		}
	}
	
	die('FAIL '. json_encode(array('error' => $upgrader->spbc_result)));
}
